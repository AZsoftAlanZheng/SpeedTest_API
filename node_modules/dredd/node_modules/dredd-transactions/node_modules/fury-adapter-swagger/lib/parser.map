{"version":3,"sources":["parser.js"],"names":["nextTick","cb","process","isExtension","value","key","startsWith","Parser","minim","source","generateSourceMap","globalSchemes","swagger","result","api","path","group","done","elements","Category","ParseResult","SourceMap","swaggerParser","loaded","isString","safeLoad","err","createAnnotation","CANNOT_PARSE","reason","mark","first","attributes","set","position","Error","message","info","undefined","paths","swaggerOptions","$refs","external","validate","details","queue","length","forEach","item","VALIDATION_ERROR","inner","push","shift","location","matches","match","indexOf","annotation","classes","handleSwaggerInfo","handleSwaggerHost","handleSwaggerAuth","handleExternalDocs","externalDocs","validateProduces","produces","validateConsumes","consumes","complete","handleSwaggerVendorExtensions","omitBy","pendingPaths","pathValue","href","handleSwaggerPath","exception","UNCAUGHT_ERROR","i","originalPath","clone","args","pop","bind","original","slice","withPath","element","docs","description","url","concat","Copy","title","createSourceMap","meta","get","content","MemberElement","Member","host","hostname","schemes","DATA_LOST","metadata","member","apiKey","config","in","name","flow","grantType","items","ArrayElement","Array","StringElement","String","scopes","descriptions","scopesList","isObject","isArray","scopeName","index","scope","oauth","Transition","authorizationUrl","transition","relation","tokenUrl","AuthScheme","securityDefinitions","keys","type","apiKeyName","oauthGrantType","oauthScopes","oauthTransitions","id","category","security","handleSwaggerSecurity","methodValue","Resource","resource","resourceDescription","useResourceGroups","updateResourceGroup","pathObjectParameters","parameters","resourceHrefVariables","createHrefVariables","hrefVariables","basePath","relevantMethods","chain","omit","method","handleSwaggerMethod","object","extensions","pickBy","Link","Extension","profileLink","extension","links","resourceParams","handleSwaggerTransitionAuth","transitionParams","queryParams","filter","parameter","hrefForTransition","toValue","summary","operationId","methodHrefVariables","relevantResponses","responses","default","p","null","createTransaction","map","responseValue","statusCode","handleSwaggerResponse","contentTypes","examples","jsonContentTypes","requestContentTypes","gatherRequestContentTypes","responseContentTypes","gatherResponseContentTypes","responseContentType","responseBody","requestContentType","transaction","handleSwaggerExampleRequest","handleSwaggerExampleResponse","contentTypeFromProduces","contentType","request","consumeIsJson","consumeIsMultipartFormData","formParams","formParamsSchema","properties","required","parametersGenerator","param","schema","pushSchemaAsset","formDataParameterCheck","convertParameterToMember","paramType","invoke","generateFormParameters","isEmpty","DataStructure","ObjectElement","Object","dataStructure","dataObject","allowEmptyValue","Asset","response","isJsonResponse","headers","updateHeaders","formattedResponseBody","serialized","bodyAsset","exampleSchema","withSlicedPath","payload","httpHeaders","headerName","prototype","hasOwnProperty","call","tags","tag","operations","operation","find","el","contains","BooleanElement","Boolean","NumberElement","Number","types","string","number","integer","boolean","array","file","validator","toElement","getLastError","detail","VALIDATION_WARNING","setAttributes","EnumElement","Enum","Type","typeForParameter","schemaForParameterValue","convertValueToElement","enum","enumerations","enumeration","convertParameterToElement","getElementClass","memberValue","ast","getPosition","isNaN","start","end","Annotation","code","fragment","params","HrefVariables","format","collectionFormat","includes","handledSchema","actualSchema","schemaAsset","generator","generateDataStructure","HttpRequest","HttpResponse","HttpTransaction","toUpperCase","validateContentTypes","parse","e","replace","internalAST","problem","AST_UNAVAILABLE","problem_mark","pointer"],"mappings":"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","file":"parser.js","sourcesContent":["// The main Swagger parsing component that outputs refract.\n\nimport _ from 'lodash';\nimport yaml from 'js-yaml';\nimport typer from 'media-typer';\nimport SwaggerParser from 'swagger-parser';\nimport ZSchema from 'z-schema';\nimport annotations from './annotations';\nimport { bodyFromSchema, bodyFromFormParameter } from './generator';\nimport uriTemplate from './uri-template';\nimport { baseLink, origin } from './link';\nimport { pushHeader, pushHeaderObject } from './headers';\nimport Ast from './ast';\nimport DataStructureGenerator from './schema';\nimport { FORM_CONTENT_TYPE, isValidContentType, isJsonContentType, isMultiPartFormData, isFormURLEncoded, hasBoundary, parseBoundary } from './media-type';\n\n\n// Provide a `nextTick` function that either is Node's nextTick or a fallback\n// for browsers\nfunction nextTick(cb) {\n  if (process && process.nextTick) {\n    process.nextTick(cb);\n  } else {\n    cb();\n  }\n}\n\n// Test whether a key is a special Swagger extension.\nfunction isExtension(value, key) {\n  return _.startsWith(key, 'x-');\n}\n\n// The parser holds state about the current parsing environment and converts\n// the input Swagger into Refract elements. The `parse` function is its main\n// interface.\nexport default class Parser {\n  constructor({ minim, source, generateSourceMap }) {\n    // Parser options\n    this.minim = minim;\n    this.source = source;\n    this.generateSourceMap = generateSourceMap;\n\n    // Global scheme requirements\n    this.globalSchemes = [];\n\n    // Loaded, dereferenced Swagger API\n    this.swagger = null;\n    // Refract parse result\n    this.result = null;\n    // Refract API category\n    this.api = null;\n    // State of the current parsing path\n    this.path = [];\n    // Current resource group, if any\n    this.group = null;\n  }\n\n  parse(done) {\n    const {\n      Category, ParseResult, SourceMap,\n    } = this.minim.elements;\n    const swaggerParser = new SwaggerParser();\n\n    this.result = new ParseResult();\n\n    // First, we load the YAML if it is a string, and handle any errors.\n    let loaded;\n    try {\n      loaded = _.isString(this.source) ? yaml.safeLoad(this.source) : this.source;\n    } catch (err) {\n      // Temporarily disable generateSourceMap while handling error\n      // This is because while handling this error we may try to generate\n      // source map which further tries to parse YAML to get source\n      // maps which causes another warning and raise conditions where we throw\n      // an error back to the caller.\n      const { generateSourceMap } = this;\n      this.generateSourceMap = false;\n\n      this.createAnnotation(\n        annotations.CANNOT_PARSE, null,\n        (err.reason || 'Problem loading the input'),\n      );\n\n      if (err.mark) {\n        this.result.first.attributes.set('sourceMap', [\n          new SourceMap([[err.mark.position, 1]]),\n        ]);\n      }\n\n      this.generateSourceMap = generateSourceMap;\n      return done(new Error(err.message), this.result);\n    }\n\n    // Some sane defaults since these are sometimes left out completely\n    if (loaded.info === undefined) {\n      loaded.info = {};\n    }\n\n    if (loaded.paths === undefined) {\n      loaded.paths = {};\n    }\n\n    // Next, we dereference and validate the loaded Swagger object. Any schema\n    // violations get converted into annotations with source maps.\n    const swaggerOptions = {\n      $refs: {\n        external: false,\n      },\n    };\n\n    return swaggerParser.validate(loaded, swaggerOptions, (err) => {\n      const swagger = swaggerParser.api;\n      this.swagger = swaggerParser.api;\n\n      if (err) {\n        if (this.swagger === undefined) {\n          return done(err, this.result);\n        }\n\n        // Non-fatal errors, so let us try and create annotations for them and\n        // continue with the parsing as best we can.\n        if (err.details) {\n          const queue = [err.details];\n\n          while (queue.length) {\n            _.forEach(queue[0], (item) => {\n              this.createAnnotation(annotations.VALIDATION_ERROR, item.path, item.message);\n\n              if (item.inner) {\n                // TODO: I am honestly not sure what the correct behavior is\n                // here. Some items will have within them a tree of other items,\n                // some of which might contain more info (but it's unclear).\n                // Do we treat them as their own error or do something else?\n                queue.push(item.inner);\n              }\n            });\n\n            queue.shift();\n          }\n\n          return done(new Error(err.message), this.result);\n        }\n\n        // Maybe there is some information in the error itself? Let's check\n        // whether it is a messed up reference!\n        let location = null;\n        const matches = err.message.match(/\\$ref pointer \"(.*?)\"/);\n\n        if (matches) {\n          location = [this.source.indexOf(matches[1]), matches[1].length];\n        }\n\n        const annotation = this.createAnnotation(annotations.VALIDATION_ERROR, null, err.message);\n\n        if (location !== null) {\n          annotation.attributes.set('sourceMap', [\n            new SourceMap([location]),\n          ]);\n        }\n\n        return done(new Error(err.message), this.result);\n      }\n\n      try {\n        // Root API Element\n        this.api = new Category();\n        this.api.classes.push('api');\n        this.result.push(this.api);\n\n        // By default there are no groups, just the root API element\n        this.group = this.api;\n\n        this.handleSwaggerInfo();\n        this.handleSwaggerHost();\n        this.handleSwaggerAuth();\n\n        this.handleExternalDocs(this.api, swagger.externalDocs);\n\n        this.validateProduces(this.swagger.produces);\n        this.validateConsumes(this.swagger.consumes);\n\n        const complete = () => {\n          this.handleSwaggerVendorExtensions(this.api, swagger.paths);\n          return done(null, this.result);\n        };\n\n        // Swagger has a paths object to loop through that describes resources\n        // We will run each path on it's own tick since it may take some time\n        // and we want to ensure that other events in the event queue are not\n        // held up.\n        const paths = _.omitBy(swagger.paths, isExtension);\n        let pendingPaths = Object.keys(paths).length;\n\n        if (pendingPaths === 0) {\n          // If there are no paths, let's go ahead and call the callback.\n          return complete();\n        }\n\n        return _.forEach(paths, (pathValue, href) => {\n          nextTick(() => {\n            this.handleSwaggerPath(pathValue, href);\n            pendingPaths -= 1;\n\n            if (pendingPaths === 0) {\n              // Last path, let's call the completion callback.\n              complete();\n            }\n          });\n        });\n      } catch (exception) {\n        this.createAnnotation(\n          annotations.UNCAUGHT_ERROR, null,\n          'There was a problem converting the Swagger document',\n        );\n\n        return done(exception, this.result);\n      }\n    });\n  }\n\n  // == Internal properties & functions ==\n\n  // Base path (URL) name for the API\n  get basePath() {\n    return (this.swagger.basePath || '').replace(/[/]+$/, '');\n  }\n\n  // Lazy-loaded input AST is made available when we need it. If it can't be\n  // loaded, then an annotation is generated with more information about why.\n  get ast() {\n    if (this.internalAST !== undefined) {\n      return this.internalAST;\n    }\n\n    if (_.isString(this.source)) {\n      try {\n        this.internalAST = new Ast(this.source);\n      } catch (err) {\n        this.internalAST = null;\n\n        let message = 'YAML Syntax Error';\n        if (err.problem) {\n          message = `${message}: ${err.problem}`;\n        }\n\n        const annotation = this.createAnnotation(annotations.AST_UNAVAILABLE, null, message);\n\n        if (err.problem_mark && err.problem_mark.pointer) {\n          const SourceMap = this.minim.getElementClass('sourceMap');\n          const position = err.problem_mark.pointer;\n\n          annotation.attributes.set('sourceMap', [\n            new SourceMap([[position, 1]]),\n          ]);\n        }\n      }\n    } else {\n      this.internalAST = null;\n      this.createAnnotation(\n        annotations.AST_UNAVAILABLE, null,\n        'Source maps are only available with string input',\n      );\n    }\n\n    return this.internalAST;\n  }\n\n  // This method lets you set the current parsing path and synchronously run\n  // a function (e.g. to create an element).\n  withPath(...args) {\n    let i;\n    const originalPath = _.clone(this.path);\n\n    for (i = 0; i < args.length - 1; i += 1) {\n      if (args[i] === '..') {\n        this.path.pop();\n      } else if (args[i] === '.') {\n        // do nothing\n      } else {\n        this.path.push(args[i]);\n      }\n    }\n\n    args[args.length - 1].bind(this)(this.path);\n\n    this.path = originalPath;\n  }\n\n  // This is like `withPath` above, but slices the path before calling by\n  // using the first argument as a length (starting at index 0).\n  withSlicedPath(...args) {\n    const original = this.path.slice(0);\n\n    // First, we slice the path, then call `withPath` and finally reset the path.\n    this.path = this.path.slice(0, args[0]);\n    this.withPath(...args.slice(1));\n    this.path = original;\n  }\n\n  handleExternalDocs(element, docs) {\n    if (!docs) {\n      return;\n    }\n\n    baseLink(element, this, 'help', {\n      description: docs.description,\n      url: docs.url,\n      path: this.path.concat(['externalDocs']),\n    });\n  }\n\n  // Converts the Swagger title and description\n  handleSwaggerInfo() {\n    const { Copy } = this.minim.elements;\n\n    if (this.swagger.info) {\n      this.withPath('info', () => {\n        if (this.swagger.info.title) {\n          this.withPath('title', () => {\n            this.api.title = this.swagger.info.title;\n\n            if (this.generateSourceMap) {\n              this.createSourceMap(this.api.meta.get('title'), this.path);\n            }\n\n            return this.api.meta.get('title');\n          });\n        }\n\n        if (this.swagger.info.description) {\n          this.withPath('description', () => {\n            const description = new Copy(this.swagger.info.description);\n            this.api.content.push(description);\n\n            if (this.generateSourceMap) {\n              this.createSourceMap(description, this.path);\n            }\n\n            return description;\n          });\n        }\n\n        this.handleSwaggerVendorExtensions(this.api, this.swagger.info);\n      });\n    }\n  }\n\n  // Converts the Swagger hostname and schemes to a Refract host metadata entry.\n  handleSwaggerHost() {\n    const { Member: MemberElement } = this.minim.elements;\n\n    if (this.swagger.host) {\n      this.withPath('host', () => {\n        let hostname = this.swagger.host;\n\n        if (this.swagger.schemes) {\n          if (this.swagger.schemes.length > 1) {\n            this.createAnnotation(\n              annotations.DATA_LOST, ['schemes'],\n              'Only the first scheme will be used to create a hostname',\n            );\n          }\n\n          hostname = `${this.swagger.schemes[0]}://${hostname}`;\n        }\n\n        const metadata = [];\n        const member = new MemberElement('HOST', hostname);\n\n        member.meta.set('classes', ['user']);\n\n        if (this.generateSourceMap) {\n          this.createSourceMap(member, this.path);\n        }\n\n        metadata.push(member);\n        this.api.attributes.set('metadata', metadata);\n\n        return member;\n      });\n    }\n  }\n\n  // Conver api key name into Refract elements\n  apiKeyName(element, apiKey) {\n    const { Member: MemberElement } = this.minim.elements;\n    let config;\n\n    if (apiKey.in === 'query') {\n      config = 'queryParameterName';\n    } else if (apiKey.in === 'header') {\n      config = 'httpHeaderName';\n    }\n\n    const member = new MemberElement(config, apiKey.name);\n\n    if (this.generateSourceMap) {\n      this.createSourceMap(member, this.path.concat(['name']));\n    }\n\n    element.content.push(member);\n  }\n\n  // Convert Oauth2 flow into Refract elements\n  oauthGrantType(element, flow) {\n    const { Member: MemberElement } = this.minim.elements;\n    let grantType = flow;\n\n    if (flow === 'password') {\n      grantType = 'resource owner password credentials';\n    } else if (flow === 'application') {\n      grantType = 'client credentials';\n    } else if (flow === 'accessCode') {\n      grantType = 'authorization code';\n    }\n\n    const member = new MemberElement('grantType', grantType);\n\n    if (this.generateSourceMap) {\n      this.createSourceMap(member, this.path.concat(['flow']));\n    }\n\n    element.content.push(member);\n  }\n\n  // Convert OAuth2 scopes into Refract elements\n  oauthScopes(element, items) {\n    const {\n      Member: MemberElement,\n      Array: ArrayElement,\n      String: StringElement,\n    } = this.minim.elements;\n\n    const scopes = new ArrayElement();\n    let descriptions = null;\n    let scopesList = items;\n\n    if (_.isObject(items) && !_.isArray(items)) {\n      descriptions = Object.values(items);\n      scopesList = Object.keys(items);\n    }\n\n    // If value is not an empty array, then they are scopes\n    _.forEach(scopesList, (scopeName, index) => {\n      const scope = new StringElement(scopeName);\n\n      if (descriptions) {\n        scope.description = descriptions[index];\n\n        if (this.generateSourceMap) {\n          this.createSourceMap(scope.meta.get('description'), this.path.concat([scopeName]));\n        }\n      }\n\n      if (this.generateSourceMap) {\n        const value = descriptions ? scopeName : index;\n        this.createSourceMap(scope, this.path.concat([value]));\n      }\n\n      scopes.content.push(scope);\n    });\n\n    if (scopes.length) {\n      element.content.push(new MemberElement('scopes', scopes));\n    }\n  }\n\n  // Conver OAuth2 transition information into Refract elements\n  oauthTransitions(element, oauth) {\n    const { Transition } = this.minim.elements;\n\n    if (oauth.authorizationUrl) {\n      const transition = new Transition();\n\n      transition.relation = 'authorize';\n      transition.href = oauth.authorizationUrl;\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(transition.attributes.get('href'), this.path.concat(['authorizationUrl']));\n        this.createSourceMap(transition.attributes.get('relation'), this.path.concat(['authorizationUrl']));\n      }\n\n      element.content.push(transition);\n    }\n\n    if (oauth.tokenUrl) {\n      const transition = new Transition();\n\n      transition.relation = 'token';\n      transition.href = oauth.tokenUrl;\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(transition.attributes.get('href'), this.path.concat(['tokenUrl']));\n        this.createSourceMap(transition.attributes.get('relation'), this.path.concat(['tokenUrl']));\n      }\n\n      element.content.push(transition);\n    }\n  }\n\n  // Convert a Swagger auth object into Refract elements.\n  handleSwaggerAuth() {\n    const { Category, AuthScheme } = this.minim.elements;\n    const schemes = [];\n\n    if (this.swagger.securityDefinitions) {\n      _.keys(this.swagger.securityDefinitions).forEach((name) => {\n        this.withPath('securityDefinitions', name, () => {\n          const item = this.swagger.securityDefinitions[name];\n          const element = new AuthScheme();\n\n          switch (item.type) {\n            case 'basic':\n              element.element = 'Basic Authentication Scheme';\n              break;\n\n            case 'apiKey':\n              element.element = 'Token Authentication Scheme';\n              this.apiKeyName(element, item);\n              break;\n\n            case 'oauth2':\n              element.element = 'OAuth2 Scheme';\n              this.oauthGrantType(element, item.flow);\n\n              if (item.scopes) {\n                this.withPath('scopes', () => {\n                  this.oauthScopes(element, item.scopes);\n                });\n              }\n\n              this.oauthTransitions(element, item);\n              break;\n\n            default:\n              break;\n          }\n\n          element.id = name;\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(element.meta.get('id'), this.path);\n          }\n\n          if (item['x-summary']) {\n            element.title = item['x-summary'];\n\n            if (this.generateSourceMap) {\n              this.createSourceMap(element.meta.get('title'), this.path.concat(['x-summary']));\n            }\n          }\n\n          if (item.description) {\n            element.description = item.description;\n\n            if (this.generateSourceMap) {\n              this.createSourceMap(element.meta.get('description'), this.path.concat(['description']));\n            }\n          }\n\n          schemes.push(element);\n        });\n      });\n    }\n\n    if (schemes.length) {\n      const category = new Category();\n\n      category.meta.set('classes', ['authSchemes']);\n      category.content = schemes;\n\n      this.api.content.push(category);\n    }\n\n    if (!this.swagger.security) {\n      return;\n    }\n\n    this.handleSwaggerSecurity(this.swagger.security, this.globalSchemes);\n  }\n\n  handleSwaggerSecurity(security, schemes) {\n    const { AuthScheme } = this.minim.elements;\n\n    _.forEach(security, (item, index) => {\n      _.keys(item).forEach((name) => {\n        this.withPath('security', index, name, () => {\n          const element = new AuthScheme();\n\n          // If value is not an empty array, then they are scopes\n          this.oauthScopes(element, item[name]);\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(element, this.path);\n          }\n\n          element.element = name;\n          schemes.push(element);\n        });\n      });\n    });\n  }\n\n  handleSwaggerTransitionAuth(methodValue) {\n    const schemes = [];\n\n    if (!methodValue.security) {\n      return this.globalSchemes;\n    }\n\n    this.handleSwaggerSecurity(methodValue.security, schemes);\n\n    return schemes;\n  }\n\n  // Convert a Swagger path into a Refract resource.\n  handleSwaggerPath(pathValue, href) {\n    const { Copy, Resource } = this.minim.elements;\n    const resource = new Resource();\n\n    this.withPath('paths', href, () => {\n      // Provide users with a way to add a title to a resource in Swagger\n      if (pathValue['x-summary']) {\n        this.withPath('x-summary', () => {\n          resource.title = pathValue['x-summary'];\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(resource.meta.get('title'), this.path);\n          }\n\n          return resource.meta.get('title');\n        });\n      }\n\n      // Provide users a way to add a description to a resource in Swagger\n      if (pathValue['x-description']) {\n        this.withPath('x-description', () => {\n          const resourceDescription = new Copy(pathValue['x-description']);\n          resource.push(resourceDescription);\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(resourceDescription, this.path);\n          }\n\n          return resourceDescription;\n        });\n      }\n\n      if (this.useResourceGroups()) {\n        this.updateResourceGroup(pathValue['x-group-name']);\n      }\n\n      this.group.content.push(resource);\n\n      const pathObjectParameters = pathValue.parameters || [];\n      const resourceHrefVariables = this.createHrefVariables(pathObjectParameters);\n\n      if (resourceHrefVariables) {\n        resource.hrefVariables = resourceHrefVariables;\n      }\n\n      // Set the resource-wide URI template, which can further be overridden\n      // by individual transition URI templates. When creating a transition\n      // below, we *only* set the transition URI template if it differs from\n      // the one we've generated here.\n      resource.href = uriTemplate(this.basePath, href, pathObjectParameters);\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(resource.attributes.get('href'), this.path);\n      }\n\n      const relevantMethods = _.chain(pathValue)\n        .omit('parameters', '$ref')\n        .omitBy(isExtension)\n        .value();\n\n      // Each path is an object with methods as properties\n      _.forEach(relevantMethods, (methodValue, method) => {\n        this.handleSwaggerMethod(resource, href, pathObjectParameters, methodValue, method);\n      });\n\n      this.handleSwaggerVendorExtensions(resource, pathValue);\n\n      return resource;\n    });\n  }\n\n  // Converts all unknown Swagger vendor extensions from an object into a API Element extension\n  handleSwaggerVendorExtensions(element, object) {\n    const extensions = _.chain(object)\n      .pickBy(isExtension)\n      .omit('x-description', 'x-summary', 'x-group-name')\n      .value();\n\n    if (Object.keys(extensions).length > 0) {\n      const { Link, Extension } = this.minim.elements;\n\n      const profileLink = new Link();\n      profileLink.relation = 'profile';\n      profileLink.href = 'https://help.apiary.io/profiles/api-elements/vendor-extensions/';\n\n      const extension = new Extension(extensions);\n      extension.links = [profileLink];\n      element.content.push(extension);\n    }\n  }\n\n  // Convert a Swagger method into a Refract transition.\n  handleSwaggerMethod(resource, href, resourceParams, methodValue, method) {\n    const { Copy, Transition } = this.minim.elements;\n    const transition = new Transition();\n\n    resource.content.push(transition);\n\n    this.withPath(method, () => {\n      const schemes = this.handleSwaggerTransitionAuth(methodValue);\n\n      this.validateProduces(methodValue.produces);\n      this.validateConsumes(methodValue.consumes);\n\n      this.handleExternalDocs(transition, methodValue.externalDocs);\n\n      const transitionParams = methodValue.parameters || [];\n\n      const queryParams = transitionParams.filter(parameter => parameter.in === 'query');\n\n      // Here we generate a URI template specific to this transition. If it\n      // is different from the resource URI template, then we set the\n      // transition's `href` attribute.\n      const hrefForTransition = uriTemplate(this.basePath, href, resourceParams, queryParams);\n\n      if (hrefForTransition !== resource.href.toValue()) {\n        transition.href = hrefForTransition;\n      }\n\n      if (methodValue.summary) {\n        this.withPath('summary', () => {\n          transition.title = methodValue.summary;\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(transition.meta.get('title'), this.path);\n          }\n\n          return transition.meta.get('title');\n        });\n      }\n\n      if (methodValue.description) {\n        this.withPath('description', () => {\n          const description = new Copy(methodValue.description);\n          transition.push(description);\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(description, this.path);\n          }\n\n          return description;\n        });\n      }\n\n      if (methodValue.operationId) {\n        // TODO: Add a source map?\n        transition.id = methodValue.operationId;\n      }\n\n      // For each uriParameter, create an hrefVariable\n      const methodHrefVariables = this.createHrefVariables(transitionParams);\n      if (methodHrefVariables) {\n        transition.hrefVariables = methodHrefVariables;\n      }\n\n      // Currently, default responses are not supported in API Description format\n      const relevantResponses = _.chain(methodValue.responses)\n        .omit('default')\n        .omitBy(isExtension)\n        .value();\n\n      if (methodValue.responses && methodValue.responses.default) {\n        this.withPath('responses', 'default', (path) => {\n          this.createAnnotation(\n            annotations.DATA_LOST, path,\n            'Default response is not yet supported',\n          );\n        });\n      }\n\n      if (_.keys(relevantResponses).length === 0) {\n        if (transitionParams.filter(p => p.in === 'body').length) {\n          // Create an empty successful response so that the request/response\n          // pair gets properly generated. In the future we may want to\n          // refactor the code below as this is a little weird.\n          relevantResponses.null = {};\n        } else {\n          this.createTransaction(transition, method, schemes.map(element => element.clone()));\n        }\n      }\n\n      // Transactions are created for each response in the document\n      _.forEach(relevantResponses, (responseValue, statusCode) => {\n        this.handleSwaggerResponse(\n          transition, method, methodValue,\n          transitionParams, responseValue, statusCode,\n          schemes.map(element => element.clone()), resourceParams,\n        );\n      });\n\n      this.handleSwaggerVendorExtensions(transition, methodValue);\n\n      return transition;\n    });\n  }\n\n  // Returns all of the content types for a request\n  // Request content types include all consumes types\n  // Returns `[null]` when there are no content types\n  gatherRequestContentTypes(methodValue) {\n    const contentTypes = (methodValue.consumes || this.swagger.consumes || [])\n      .filter(isValidContentType);\n\n    if (contentTypes.length === 0) {\n      return [null];\n    }\n\n    return contentTypes;\n  }\n\n  // Returns all of the content types for a response\n  // Response content types include all example types OR the first JSON content type\n  // Returns `[null]` when there are no content types\n  gatherResponseContentTypes(methodValue, examples) {\n    let contentTypes = [];\n\n    if (examples && Object.keys(examples).length > 0) {\n      contentTypes = Object.keys(examples);\n    } else {\n      const produces = (methodValue.produces || this.swagger.produces || []);\n      const jsonContentTypes = produces.filter(isJsonContentType);\n\n      if (jsonContentTypes.length > 0) {\n        contentTypes = [jsonContentTypes[0]];\n      }\n    }\n\n    contentTypes = contentTypes.filter(isValidContentType);\n\n    if (contentTypes.length === 0) {\n      return [null];\n    }\n\n    return contentTypes;\n  }\n\n  // Convert a Swagger response & status code into Refract transactions.\n  handleSwaggerResponse(\n    transition, method, methodValue, transitionParams,\n    responseValue, statusCode, schemes, resourceParams,\n  ) {\n    const requestContentTypes = this.gatherRequestContentTypes(methodValue);\n    const responseContentTypes = this\n      .gatherResponseContentTypes(methodValue, responseValue.examples);\n\n    responseContentTypes.forEach((responseContentType) => {\n      let responseBody;\n\n      if (responseContentType && responseValue.examples &&\n          responseValue.examples[responseContentType]) {\n        responseBody = responseValue.examples[responseContentType];\n      }\n\n      requestContentTypes.forEach((requestContentType) => {\n        const transaction = this.createTransaction(transition, method, schemes);\n\n        this.handleSwaggerExampleRequest(\n          transaction, methodValue, transitionParams,\n          resourceParams, requestContentType, responseContentType, responseBody === undefined,\n        );\n\n        this.handleSwaggerExampleResponse(\n          transaction, methodValue, responseValue,\n          statusCode, responseBody, responseContentType,\n        );\n      });\n    });\n  }\n\n  // Convert a Swagger example into a Refract request.\n  handleSwaggerExampleRequest(\n    transaction, methodValue, transitionParams, resourceParams,\n    requestContentType, responseContentType, contentTypeFromProduces,\n  ) {\n    let contentType = requestContentType;\n    const { request } = transaction;\n\n    this.withPath(() => {\n      const consumeIsJson = contentType && isJsonContentType(contentType);\n      const consumeIsMultipartFormData = contentType && isMultiPartFormData(contentType);\n\n      if (consumeIsMultipartFormData && !hasBoundary(contentType)) {\n        // When multipart/form-data conntent type doesn't have a boundary\n        // add a default one `BOUNDARY` which hopefully isn't found\n        // in an example content. `parseBoundary` will provide the default.\n        contentType += `; boundary=${parseBoundary(contentType)}`;\n      }\n\n      if (contentType) {\n        pushHeader('Content-Type', contentType, request, this, 'consumes-content-type');\n      }\n\n      if (responseContentType) {\n        if (contentTypeFromProduces) {\n          pushHeader('Accept', responseContentType, request, this, 'produces-accept');\n        } else {\n          pushHeader('Accept', responseContentType, request, this);\n        }\n      }\n\n      const formParams = [];\n      let formParamsSchema = { type: 'object', properties: {}, required: [] };\n\n      const parametersGenerator = {};\n\n      _.forEach([\n        [resourceParams, '..'],\n        [transitionParams, '.'],\n      ], (parameters) => {\n        _.forEach(parameters[0], (param, index) => {\n          switch (param.in) {\n            case 'header':\n              _.set(parametersGenerator, [param.in, param.name], _.bind(this.withPath, this, parameters[1], 'parameters', index, () => {\n                pushHeaderObject(param.name, param, request, this);\n              }));\n              break;\n\n            case 'body':\n              _.set(parametersGenerator, [param.in, param.name], _.bind(this.withPath, this, parameters[1], 'parameters', index, () => {\n                if (param['x-example']) {\n                  this.withPath('x-example', () => {\n                    this.createAnnotation(\n                      annotations.VALIDATION_ERROR, this.path,\n                      'The \\'x-example\\' property isn\\'t allowed for body parameters - use \\'schema.example\\' instead',\n                    );\n                  });\n                }\n\n                this.withPath('schema', () => {\n                  if (consumeIsJson) {\n                    bodyFromSchema(param.schema, request, this, contentType);\n                  }\n\n                  this.pushSchemaAsset(param.schema, request, this.path);\n                });\n              }));\n              break;\n\n            case 'formData':\n              _.set(parametersGenerator, [param.in, param.name], _.bind(this.withPath, this, parameters[1], 'parameters', index, () => {\n                this.formDataParameterCheck(param);\n                formParamsSchema = bodyFromFormParameter(param, formParamsSchema);\n                const member = this.convertParameterToMember(param);\n                formParams.push(member);\n              }));\n              break;\n\n            default:\n          }\n        });\n      });\n\n      _.forEach(parametersGenerator, (paramType) => {\n        _.forEach(paramType, (invoke) => {\n          invoke();\n        });\n      });\n\n      if (!contentType || consumeIsMultipartFormData || isFormURLEncoded(contentType)) {\n        this.generateFormParameters(formParams, formParamsSchema, request, contentType);\n      }\n\n      // Using form parameters instead of body? We will convert those to\n      // data structures and will generate form-urlencoded body.\n      return request;\n    });\n  }\n\n  generateFormParameters(parameters, schema, request, contentType) {\n    if (_.isEmpty(parameters)) {\n      return;\n    }\n\n    const { DataStructure, Object: ObjectElement } = this.minim.elements;\n\n    if (!contentType) {\n      // No content type was provided, lets default to first form\n      pushHeader('Content-Type', FORM_CONTENT_TYPE, request, this, 'form-data-content-type');\n    }\n\n    bodyFromSchema(schema, request, this, contentType || FORM_CONTENT_TYPE);\n\n    // Generating data structure\n    const dataStructure = new DataStructure();\n\n    // A form is essentially an object with key/value members\n    const dataObject = new ObjectElement();\n\n    _.forEach(parameters, (param) => {\n      dataObject.content.push(param);\n    });\n\n    dataStructure.content = dataObject;\n    request.content.push(dataStructure);\n  }\n\n  formDataParameterCheck(param) {\n    if (param.type === 'array') {\n      this.createAnnotation(\n        annotations.DATA_LOST, this.path,\n        'Arrays in form parameters are not fully supported yet',\n      );\n\n      return;\n    }\n\n    if (param.allowEmptyValue) {\n      this.createAnnotation(\n        annotations.DATA_LOST, this.path,\n        'The allowEmptyValue flag is not fully supported yet',\n      );\n    }\n  }\n\n  // Convert a Swagger example into a Refract response.\n  handleSwaggerExampleResponse(\n    transaction, methodValue, responseValue,\n    statusCode, responseBody, contentType,\n  ) {\n    const { Asset, Copy } = this.minim.elements;\n    const { response } = transaction;\n\n    this.withPath('responses', statusCode, () => {\n      if (responseValue.description) {\n        const description = new Copy(responseValue.description);\n        response.content.push(description);\n\n        if (this.generateSourceMap) {\n          this.createSourceMap(description, this.path.concat(['description']));\n        }\n      }\n\n      if (contentType) {\n        if (responseValue.examples && responseValue.examples[contentType]) {\n          this.withPath('examples', contentType, () => {\n            pushHeader('Content-Type', contentType, response, this);\n          });\n        } else {\n          pushHeader('Content-Type', contentType, response, this, 'produces-content-type');\n        }\n      }\n\n      const isJsonResponse = isJsonContentType(contentType);\n\n      if (responseValue.headers) {\n        this.updateHeaders(response, responseValue.headers);\n      }\n\n      this.withPath('examples', () => {\n        // Responses can have bodies\n        if (responseBody !== undefined) {\n          this.withPath(contentType, () => {\n            let formattedResponseBody = responseBody;\n            let serialized = true;\n\n            if (typeof responseBody !== 'string') {\n              try {\n                formattedResponseBody = JSON.stringify(responseBody, null, 2);\n              } catch (exception) {\n                this.createAnnotation(annotations.DATA_LOST, this.path, 'Circular references in examples are not yet supported.');\n                serialized = false;\n              }\n            }\n\n            if (serialized) {\n              const bodyAsset = new Asset(formattedResponseBody);\n              bodyAsset.classes.push('messageBody');\n\n              if (this.generateSourceMap) {\n                this.createSourceMap(bodyAsset, this.path);\n              }\n\n              response.content.push(bodyAsset);\n            }\n          });\n        }\n\n        // Responses can have schemas in Swagger\n        const exampleSchema = responseValue.examples && responseValue.examples.schema;\n        const schema = responseValue.schema || exampleSchema;\n\n        if (schema) {\n          let args;\n\n          if (responseValue.examples && responseValue.examples.schema) {\n            args = [5, 'examples', 'schema'];\n          } else {\n            args = [5, 'schema'];\n          }\n\n          this.withSlicedPath(...args.concat([() => {\n            if (isJsonResponse && responseBody === undefined) {\n              bodyFromSchema(schema, response, this, contentType);\n            }\n\n            this.pushSchemaAsset(schema, response, this.path);\n          }]));\n        }\n\n        if (statusCode !== 'null') {\n          response.statusCode = statusCode;\n\n          if (this.generateSourceMap) {\n            this.createSourceMap(response.attributes.get('statusCode'), this.path.slice(0, -1));\n          }\n        }\n      });\n\n\n      this.handleSwaggerVendorExtensions(response, responseValue);\n\n      return response;\n    });\n  }\n\n  // Takes in an `payload` element and a list of Swagger headers. Adds\n  // the Swagger headers to the headers element in the payload\n  updateHeaders(payload, httpHeaders) {\n    _.forEach(_.keys(httpHeaders), (headerName) => {\n      if (Object.prototype.hasOwnProperty.call(httpHeaders, headerName)) {\n        // eslint-disable-next-line no-loop-func\n        this.withPath('headers', headerName, () => {\n          pushHeaderObject(headerName, httpHeaders[headerName], payload, this);\n        });\n      }\n    });\n  }\n\n  // Test whether tags can be treated as resource groups, and if so it sets a\n  // group name for each resource (used later to create groups).\n  useResourceGroups() {\n    const tags = [];\n\n    if (this.swagger.paths) {\n      _.forEach(this.swagger.paths, (path) => {\n        let tag = null;\n\n        if (path) {\n          const operations = _.omitBy(path, isExtension);\n\n          // eslint-disable-next-line consistent-return\n          _.forEach(operations, (operation) => {\n            if (operation.tags && operation.tags.length) {\n              if (operation.tags.length > 1) {\n                // Too many tags... each resource can only be in one group!\n                return false;\n              }\n\n              if (tag === null) {\n                [tag] = operation.tags;\n              } else if (tag !== operation.tags[0]) {\n                // Non-matching tags... can't have a resource in multiple groups!\n                return false;\n              }\n            }\n          });\n        }\n\n        if (tag) {\n          // eslint-disable-next-line no-param-reassign\n          path['x-group-name'] = tag;\n          tags.push(tag);\n        }\n      });\n    }\n\n    return tags.length > 0;\n  }\n\n  // Update the current group by either selecting or creating it.\n  updateResourceGroup(name) {\n    const { Category, Copy } = this.minim.elements;\n\n    if (name) {\n      this.group = this.api.find(el => el.element === 'category' && el.classes.contains('resourceGroup') && el.title.toValue() === name).first;\n\n      if (!this.group) {\n        // TODO: Source maps for these groups. The problem is that the location\n        // may not always make sense. Do we point to the tag description,\n        // the resource, or the transition?\n        this.group = new Category();\n        this.group.title = name;\n        this.group.classes.push('resourceGroup');\n\n        if (this.swagger.tags && _.isArray(this.swagger.tags)) {\n          _.forEach(this.swagger.tags, (tag) => {\n            if (tag.name === name && tag.description) {\n              this.group.content.push(new Copy(tag.description));\n            }\n\n            this.handleExternalDocs(this.group, tag.externalDocs);\n          });\n        }\n\n        this.api.content.push(this.group);\n      }\n    }\n  }\n\n  /* eslint-disable class-methods-use-this */\n  schemaForParameterValue(parameter) {\n    const schema = {\n      type: parameter.type,\n    };\n\n    if (schema.type === 'integer') {\n      schema.type = 'number';\n    }\n\n    if (parameter.items) {\n      schema.items = parameter.items;\n    }\n\n    return schema;\n  }\n\n  typeForParameter(parameter) {\n    const {\n      Array: ArrayElement, Boolean: BooleanElement, Number: NumberElement,\n      String: StringElement,\n    } = this.minim.elements;\n\n    const types = {\n      string: StringElement,\n      number: NumberElement,\n      integer: NumberElement,\n      boolean: BooleanElement,\n      array: ArrayElement,\n      file: StringElement,\n    };\n\n    return types[parameter.type];\n  }\n\n  convertValueToElement(value, schema) {\n    const validator = new ZSchema();\n    let element;\n\n    if (validator.validate(value, schema)) {\n      element = this.minim.toElement(value);\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(element, this.path);\n      }\n    } else {\n      validator.getLastError().details.forEach((detail) => {\n        this.createAnnotation(annotations.VALIDATION_WARNING, this.path, detail.message);\n      });\n\n      // Coerce parameter to correct type\n      if (schema.type === 'string') {\n        if (typeof value === 'number' || typeof value === 'boolean') {\n          element = new this.minim.elements.String(String(value));\n        }\n      }\n    }\n\n    return element;\n  }\n\n  // Convert a Swagger parameter into a Refract element.\n  convertParameterToElement(parameter, setAttributes = false) {\n    const { Array: ArrayElement, Enum: EnumElement } = this.minim.elements;\n\n    const Type = this.typeForParameter(parameter);\n    const schema = this.schemaForParameterValue(parameter);\n\n    let element = new Type();\n\n    if (parameter['x-example'] !== undefined) {\n      this.withPath('x-example', () => {\n        const value = this.convertValueToElement(parameter['x-example'], schema);\n\n        if (value) {\n          element = value;\n        }\n      });\n    }\n\n    if (parameter.enum) {\n      if (element.toValue()) {\n        element = new EnumElement(element);\n      } else {\n        element = new EnumElement();\n      }\n\n      const enumerations = new ArrayElement();\n\n      parameter.enum.forEach((value, index) => {\n        this.withPath('enum', index, () => {\n          const enumeration = this.convertValueToElement(value, schema);\n\n          if (enumeration) {\n            enumerations.push(enumeration);\n          }\n        });\n      });\n\n      element.enumerations = enumerations;\n    }\n\n    if (parameter.default) {\n      this.withPath('default', () => {\n        let value = this.convertValueToElement(parameter.default, schema);\n\n        if (value) {\n          if (parameter.enum) {\n            value = new EnumElement(value);\n          }\n\n          element.attributes.set('default', value);\n        }\n      });\n    }\n\n    if (parameter.type === 'array' && parameter.items && element.content.length === 0) {\n      this.withPath('items', () => {\n        element.content = [this.convertParameterToElement(parameter.items, true)];\n      });\n    }\n\n    if (this.generateSourceMap) {\n      this.createSourceMap(element, this.path);\n    }\n\n    if (setAttributes) {\n      if (parameter.description) {\n        element.description = parameter.description;\n\n        if (this.generateSourceMap) {\n          this.createSourceMap(element.meta.get('description'), this.path.concat(['description']));\n        }\n      }\n\n      if (parameter.required) {\n        element.attributes.set('typeAttributes', ['required']);\n      }\n    }\n\n    return element;\n  }\n\n  // Convert a Swagger parameter into a Refract member element for use in an\n  // object element (or subclass).\n  convertParameterToMember(parameter) {\n    const MemberElement = this.minim.getElementClass('member');\n    const memberValue = this.convertParameterToElement(parameter);\n\n    // TODO: Update when Minim has better support for elements as values\n    // should be: new MemberType(parameter.name, memberValue);\n    const member = new MemberElement(parameter.name);\n    member.content.value = memberValue;\n\n    if (this.generateSourceMap) {\n      this.createSourceMap(member, this.path);\n    }\n\n    if (parameter.description) {\n      member.description = parameter.description;\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(member.meta.get('description'), this.path.concat(['description']));\n      }\n    }\n\n    if (parameter.required) {\n      member.attributes.set('typeAttributes', ['required']);\n    }\n\n    return member;\n  }\n\n  // Make a new source map for the given element\n  createSourceMap(element, path) {\n    if (this.ast) {\n      const SourceMap = this.minim.getElementClass('sourceMap');\n      const position = this.ast.getPosition(path);\n\n      // eslint-disable-next-line no-restricted-globals\n      if (position && !isNaN(position.start) && !isNaN(position.end)) {\n        element.attributes.set('sourceMap', [\n          new SourceMap([[position.start, position.end - position.start]]),\n        ]);\n      }\n    }\n  }\n\n  // Make a new annotation for the given path and message\n  createAnnotation(info, path, message) {\n    const { Annotation } = this.minim.elements;\n\n    const annotation = new Annotation(message);\n    annotation.classes.push(info.type);\n    annotation.code = info.code;\n\n    this.result.content.push(annotation);\n\n    if (info.fragment) {\n      origin(info.fragment, annotation, this);\n    }\n\n    if (path && this.ast) {\n      this.createSourceMap(annotation, path);\n    }\n\n    return annotation;\n  }\n\n  // Create a new HrefVariables element from a parameter list. Returns either\n  // the new HrefVariables element or `undefined`.\n  createHrefVariables(params) {\n    const { HrefVariables } = this.minim.elements;\n    const hrefVariables = new HrefVariables();\n\n    _.forEach(params, (parameter, index) => {\n      this.withPath('parameters', index, () => {\n        let member;\n        const format = parameter.collectionFormat || 'csv';\n\n        // Adding a warning if format is not supported\n        if (!['multi', 'csv'].includes(format)) {\n          this.createAnnotation(\n            annotations.DATA_LOST, this.path,\n            `Parameters of collection format '${format}' are not supported`,\n          );\n        }\n\n        if (parameter.in === 'query' || parameter.in === 'path') {\n          member = this.convertParameterToMember(parameter);\n          hrefVariables.content.push(member);\n        }\n\n        return member;\n      });\n    });\n\n    return hrefVariables.length ? hrefVariables : undefined;\n  }\n\n  // Create a Refract asset element containing JSON Schema and push into payload\n  pushSchemaAsset(schema, payload, path) {\n    let handledSchema = false;\n    let actualSchema = _.omit(schema, ['discriminator', 'readOnly', 'xml', 'externalDocs', 'example']);\n    actualSchema = _.omitBy(actualSchema, isExtension);\n\n    try {\n      const Asset = this.minim.getElementClass('asset');\n      const schemaAsset = new Asset(JSON.stringify(actualSchema));\n\n      schemaAsset.classes.push('messageBodySchema');\n      schemaAsset.contentType = 'application/schema+json';\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(schemaAsset, path);\n      }\n\n      this.handleExternalDocs(schemaAsset, schema.externalDocs);\n\n      payload.content.push(schemaAsset);\n      handledSchema = true;\n    } catch (exception) {\n      this.createAnnotation(\n        annotations.DATA_LOST, path,\n        'Circular references in schema are not yet supported',\n      );\n    }\n\n    if (handledSchema) {\n      try {\n        const generator = new DataStructureGenerator(this.minim);\n        const dataStructure = generator.generateDataStructure(schema);\n        if (dataStructure) {\n          payload.content.push(dataStructure);\n        }\n      } catch (exception) {\n        // TODO: Expose errors once feature is more-complete\n      }\n    }\n  }\n\n  // Create a new Refract transition element with a blank request and response.\n  createTransaction(transition, method, schemes) {\n    const { HttpRequest, HttpResponse, HttpTransaction } = this.minim.elements;\n    const transaction = new HttpTransaction();\n    transaction.content = [new HttpRequest(), new HttpResponse()];\n\n    if (transition) {\n      transition.content.push(transaction);\n    }\n\n    if (method) {\n      transaction.request.method = method.toUpperCase();\n\n      if (this.generateSourceMap) {\n        this.createSourceMap(transaction.request.attributes.get('method'), this.path);\n      }\n    }\n\n    if (schemes.length) {\n      transaction.attributes.set('authSchemes', schemes);\n    }\n\n    return transaction;\n  }\n\n  validateProduces(produces) {\n    if (produces) {\n      this.withPath('produces', () => {\n        this.validateContentTypes(produces);\n      });\n    }\n  }\n\n  validateConsumes(consumes) {\n    if (consumes) {\n      this.withPath('consumes', () => {\n        this.validateContentTypes(consumes);\n      });\n    }\n  }\n\n  validateContentTypes(contentTypes) {\n    contentTypes.forEach((contentType) => {\n      try {\n        typer.parse(contentType);\n      } catch (e) {\n        const index = contentTypes.indexOf(contentType);\n        this.withPath(index, () => {\n          this.createAnnotation(\n            annotations.VALIDATION_WARNING, this.path,\n            `Invalid content type '${contentType}', ${e.message}`,\n          );\n        });\n      }\n    });\n  }\n}\n\n"]}