{"version":3,"sources":["headers.js"],"names":["createHeaders","pushHeader","pushHeaderObject","payload","parser","HttpHeaders","minim","elements","headers","key","value","fragment","MemberElement","Member","header","duplicate","find","member","content","toLowerCase","length","first","_meta","toElement","undefined","generateSourceMap","createSourceMap","path","push","type","createAnnotation","DATA_LOST","enum","default","headerElement","description","meta","get","concat"],"mappings":";;;;;;;;;;QAGgBA,a,GAAAA,a;QASAC,U,GAAAA,U;QAkCAC,gB,GAAAA,gB;;AA9ChB;;AACA;;;;;;AAEO,SAASF,aAAT,CAAuBG,OAAvB,EAAgCC,MAAhC,EAAwC;AAAA,MACrCC,WADqC,GACrBD,OAAOE,KAAP,CAAaC,QADQ,CACrCF,WADqC;;;AAG7C,MAAMG,UAAU,IAAIH,WAAJ,EAAhB;;AAEA;AACAF,UAAQK,OAAR,GAAkBL,QAAQK,OAAR,IAAmBA,OAArC;AACD;;AAEM,SAASP,UAAT,CAAoBQ,GAApB,EAAyBC,KAAzB,EAAgCP,OAAhC,EAAyCC,MAAzC,EAAiDO,QAAjD,EAA2D;AAAA,MAChDC,aADgD,GAC9BR,OAAOE,KAAP,CAAaC,QADiB,CACxDM,MADwD;;AAEhE,MAAIC,eAAJ;;AAEAd,gBAAcG,OAAd,EAAuBC,MAAvB;;AAEA,MAAMW,YAAYZ,QAAQK,OAAR,CAAgBQ,IAAhB,CAAqB;AAAA,WACrCC,OAAOR,GAAP,CAAWS,OAAX,CAAmBC,WAAnB,OAAqCV,IAAIU,WAAJ,EADA;AAAA,GAArB,CAAlB;;AAGA,MAAIJ,UAAUK,MAAd,EAAsB;AACpBN,aAASC,UAAUM,KAAnB;AACAP,WAAOJ,KAAP,GAAeA,KAAf;AACD,GAHD,MAGO;AACLI,aAAS,IAAIF,aAAJ,CAAkBH,GAAlB,EAAuBC,KAAvB,CAAT;AACD;;AAED,MAAIC,QAAJ,EAAc;AACZ,wBAASA,QAAT,EAAmBG,MAAnB,EAA2BV,MAA3B;AACD,GAFD,MAEO;AACL;AACAU,WAAOQ,KAAP,GAAelB,OAAOE,KAAP,CAAaiB,SAAb,CAAuB,EAAvB,CAAf;AACD;;AAED,MAAIZ,aAAaa,SAAb,IAA0BpB,OAAOqB,iBAArC,EAAwD;AACtDrB,WAAOsB,eAAP,CAAuBZ,MAAvB,EAA+BV,OAAOuB,IAAtC;AACD;;AAED,MAAI,CAACZ,UAAUK,MAAf,EAAuB;AACrBjB,YAAQK,OAAR,CAAgBoB,IAAhB,CAAqBd,MAArB;AACD;;AAED,SAAOA,MAAP;AACD;;AAEM,SAASZ,gBAAT,CAA0BO,GAA1B,EAA+BK,MAA/B,EAAuCX,OAAvC,EAAgDC,MAAhD,EAAwD;AAC7D,MAAIM,QAAQ,EAAZ;;AAEA,MAAII,OAAOe,IAAP,KAAgB,OAApB,EAA6B;AAC3B;AACAzB,WAAO0B,gBAAP,CACE,sBAAYC,SADd,EACyB3B,OAAOuB,IADhC,EAEE,6CAFF;;AAKA;AACD;;AAED;AACA,MAAIb,OAAOkB,IAAX,EAAiB;AAAA,oDAELlB,OAAOkB,IAFF;AACf;;;AACCtB,SAFc;AAGhB;;AAED,MAAII,OAAO,WAAP,CAAJ,EAAyB;AACvBJ,YAAQI,OAAO,WAAP,CAAR;AACD,GAFD,MAEO,IAAIA,OAAOmB,OAAX,EAAoB;AACzBvB,YAAQI,OAAOmB,OAAf;AACD;;AAED,MAAMC,gBAAgBjC,WAAWQ,GAAX,EAAgBC,KAAhB,EAAuBP,OAAvB,EAAgCC,MAAhC,CAAtB;;AAEA,MAAIU,OAAOqB,WAAX,EAAwB;AACtBD,kBAAcC,WAAd,GAA4BrB,OAAOqB,WAAnC;;AAEA,QAAI/B,OAAOqB,iBAAX,EAA8B;AAC5BrB,aAAOsB,eAAP,CAAuBQ,cAAcE,IAAd,CAAmBC,GAAnB,CAAuB,aAAvB,CAAvB,EAA8DjC,OAAOuB,IAAP,CAAYW,MAAZ,CAAmB,CAAC,aAAD,CAAnB,CAA9D;AACD;AACF;AACF;;kBAEc,EAAErC,sBAAF,EAAcC,kCAAd,E","file":"headers.js","sourcesContent":["import { inferred } from './link';\nimport annotations from './annotations';\n\nexport function createHeaders(payload, parser) {\n  const { HttpHeaders } = parser.minim.elements;\n\n  const headers = new HttpHeaders();\n\n  // eslint-disable-next-line no-param-reassign\n  payload.headers = payload.headers || headers;\n}\n\nexport function pushHeader(key, value, payload, parser, fragment) {\n  const { Member: MemberElement } = parser.minim.elements;\n  let header;\n\n  createHeaders(payload, parser);\n\n  const duplicate = payload.headers.find(member =>\n    member.key.content.toLowerCase() === key.toLowerCase());\n\n  if (duplicate.length) {\n    header = duplicate.first;\n    header.value = value;\n  } else {\n    header = new MemberElement(key, value);\n  }\n\n  if (fragment) {\n    inferred(fragment, header, parser);\n  } else {\n    // eslint-disable-next-line no-underscore-dangle\n    header._meta = parser.minim.toElement({});\n  }\n\n  if (fragment === undefined && parser.generateSourceMap) {\n    parser.createSourceMap(header, parser.path);\n  }\n\n  if (!duplicate.length) {\n    payload.headers.push(header);\n  }\n\n  return header;\n}\n\nexport function pushHeaderObject(key, header, payload, parser) {\n  let value = '';\n\n  if (header.type === 'array') {\n    // TODO: Support collectionFormat once arrays are supported\n    parser.createAnnotation(\n      annotations.DATA_LOST, parser.path,\n      'Headers of type array are not yet supported',\n    );\n\n    return;\n  }\n\n  // Choose the first available option\n  if (header.enum) {\n    // TODO: This may lose data if there are multiple enums.\n    [value] = header.enum;\n  }\n\n  if (header['x-example']) {\n    value = header['x-example'];\n  } else if (header.default) {\n    value = header.default;\n  }\n\n  const headerElement = pushHeader(key, value, payload, parser);\n\n  if (header.description) {\n    headerElement.description = header.description;\n\n    if (parser.generateSourceMap) {\n      parser.createSourceMap(headerElement.meta.get('description'), parser.path.concat(['description']));\n    }\n  }\n}\n\nexport default { pushHeader, pushHeaderObject };\n"]}