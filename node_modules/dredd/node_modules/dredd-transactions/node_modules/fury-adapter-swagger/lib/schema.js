'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Data Structure Generator
 * Generates a dataStructure element from a JSON schema.
 *
 * >>> const generator = new DataStructureGenerator(minimNamespace);
 * >>> const dataStructure = generator.generateDataStructure({type: 'string'});
*/
var DataStructureGenerator = function () {
  function DataStructureGenerator(minim) {
    (0, _classCallCheck3.default)(this, DataStructureGenerator);

    this.minim = minim;
  }

  // Generates a data structure element representing the given schema


  (0, _createClass3.default)(DataStructureGenerator, [{
    key: 'generateDataStructure',
    value: function generateDataStructure(schema) {
      var element = this.generateElement(schema);

      if (!element) {
        return null;
      }

      var DataStructure = this.minim.elements.DataStructure;

      var dataStructure = new DataStructure(element);
      return dataStructure;
    }

    // Generates a member element for a property in a schema

  }, {
    key: 'generateMember',
    value: function generateMember(name, property) {
      var _minim$elements = this.minim.elements,
          StringElement = _minim$elements.String,
          MemberElement = _minim$elements.Member;


      var member = new MemberElement();
      member.key = new StringElement(name);
      member.value = this.generateElement(property);

      if (property.description) {
        member.description = property.description;
      }

      return member;
    }

    // Generates an enum element for the given enum schema

  }, {
    key: 'generateEnum',
    value: function generateEnum(schema) {
      var EnumElement = this.minim.elements.Enum;


      var element = new EnumElement();

      element.enumerations = schema.enum;

      return element;
    }

    // Generates an object element from the given object schema

  }, {
    key: 'generateObject',
    value: function generateObject(schema) {
      var _this = this;

      var ObjectElement = this.minim.elements.Object;


      var properties = schema.properties || {};
      var required = schema.required || [];

      if (schema.allOf && Array.isArray(schema.allOf)) {
        // Merge all of the object allOf into properties and required
        var allOf = schema.allOf.filter(function (subschema) {
          return subschema.type === 'object';
        });

        var allProperties = allOf.filter(function (subschema) {
          return subschema.properties;
        }).map(function (subschema) {
          return subschema.properties;
        });
        properties = _assign2.default.apply(Object, [properties].concat((0, _toConsumableArray3.default)(allProperties)));

        required = allOf.filter(function (subschema) {
          return subschema.required;
        }).map(function (subschema) {
          return subschema.required;
        }).reduce(function (accumulator, property) {
          return accumulator.concat(property);
        }, required);
      }

      var element = new ObjectElement();
      element.content = _lodash2.default.map(properties, function (subschema, property) {
        var member = _this.generateMember(property, subschema);

        var isRequired = required.indexOf(property) !== -1;
        member.attributes.set('typeAttributes', [isRequired ? 'required' : 'optional']);

        return member;
      });

      return element;
    }

    // Generates an array element from the given array schema

  }, {
    key: 'generateArray',
    value: function generateArray(schema) {
      var _this2 = this;

      var ArrayElement = this.minim.elements.Array;

      var element = new ArrayElement();

      if (schema.items) {
        if (_lodash2.default.isArray(schema.items)) {
          schema.items.forEach(function (item) {
            var itemElement = _this2.generateElement(item);
            if (itemElement) {
              element.push(itemElement);
            }
          });
        } else {
          var itemElement = this.generateElement(schema.items);
          if (itemElement) {
            element.push(itemElement);
          }
        }
      }

      return element;
    }

    // Generates an array of descriptions for each validation rule in the given schema.

  }, {
    key: 'generateValidationDescriptions',
    value: function generateValidationDescriptions(schema) {
      var validations = {
        // String
        pattern: function pattern(value) {
          return 'Matches regex pattern: `' + value + '`';
        },
        maxLength: function maxLength(value) {
          return 'Length of string must be less than, or equal to ' + value;
        },
        minLength: function minLength(value) {
          return 'Length of string must be greater than, or equal to ' + value;
        },

        // Number
        multipleOf: function multipleOf(value) {
          return 'Number must be a multiple of ' + value;
        },
        maximum: function maximum(value) {
          return 'Number must be less than, or equal to ' + value;
        },
        minimum: function minimum(value) {
          return 'Number must be more than, or equal to ' + value;
        },
        exclusiveMaximum: function exclusiveMaximum(value) {
          return 'Number must be less than ' + value;
        },
        exclusiveMinimum: function exclusiveMinimum(value) {
          return 'Number must be more than ' + value;
        },

        // Object
        minProperties: function minProperties(value) {
          return 'Object must have more than, or equal to ' + value + ' properties';
        },
        maxProperties: function maxProperties(value) {
          return 'Object must have less than, or equal to ' + value + ' properties';
        },

        // Array
        maxItems: function maxItems(value) {
          return 'Array length must be less than, or equal to ' + value;
        },
        minItems: function minItems(value) {
          return 'Array length must be more than, or equal to ' + value;
        },
        uniqueItems: function uniqueItems() {
          return 'Array contents must be unique';
        },

        // Other
        format: function format(value) {
          return 'Value must be of format \'' + value + '\'';
        }
      };

      return _lodash2.default.chain(validations).map(function (value, key) {
        if (schema[key]) {
          return value(schema[key]);
        }

        return null;
      }).compact().value();
    }

    // Generates an element representing the given schema

  }, {
    key: 'generateElement',
    value: function generateElement(schema) {
      var _minim$elements2 = this.minim.elements,
          StringElement = _minim$elements2.String,
          NumberElement = _minim$elements2.Number,
          BooleanElement = _minim$elements2.Boolean,
          NullElement = _minim$elements2.Null,
          EnumElement = _minim$elements2.Enum;


      var typeGeneratorMap = {
        boolean: BooleanElement,
        string: StringElement,
        number: NumberElement,
        integer: NumberElement,
        null: NullElement
      };

      var element = void 0;

      if (schema.enum) {
        element = this.generateEnum(schema);
      } else if (schema.type === 'array') {
        element = this.generateArray(schema);
      } else if (schema.type === 'object') {
        element = this.generateObject(schema);
      } else if (schema.type && typeGeneratorMap[schema.type]) {
        element = new typeGeneratorMap[schema.type]();
      } else if (_lodash2.default.isArray(schema.type)) {
        // TODO: Support multiple `type`
      }

      if (element) {
        if (schema.title) {
          element.title = new StringElement(schema.title);
        }

        if (schema.description) {
          element.description = new StringElement(schema.description);
        }

        var def = schema.default;

        if (def !== undefined && !_lodash2.default.isArray(def) && !_lodash2.default.isObject(def)) {
          // TODO Support defaults for arrays and objects
          if (schema.enum) {
            def = new EnumElement(def);
          }

          element.attributes.set('default', def);
        }

        var samples = [];

        if (schema.examples) {
          samples = schema.examples;
        } else if (schema.example) {
          samples = [schema.example];
        }

        if (samples.length) {
          if (schema.enum) {
            samples = samples.map(function (item) {
              return new EnumElement(item);
            });
          }

          element.attributes.set('samples', samples);
        }

        var validationDescriptions = this.generateValidationDescriptions(schema);

        if (validationDescriptions.length > 0) {
          var description = validationDescriptions.map(function (value) {
            return '- ' + value;
          });

          if (element.description && element.description.toValue()) {
            description.splice(0, 0, element.description.toValue() + '\n');
          }

          element.description = new StringElement(description.join('\n'));
        }
      }

      return element;
    }
  }]);
  return DataStructureGenerator;
}(); /* eslint-disable class-methods-use-this */

exports.default = DataStructureGenerator;
//# sourceMappingURL=schema.map