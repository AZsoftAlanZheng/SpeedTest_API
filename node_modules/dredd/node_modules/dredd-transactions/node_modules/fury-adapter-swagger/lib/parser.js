'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _mediaTyper = require('media-typer');

var _mediaTyper2 = _interopRequireDefault(_mediaTyper);

var _swaggerParser = require('swagger-parser');

var _swaggerParser2 = _interopRequireDefault(_swaggerParser);

var _zSchema = require('z-schema');

var _zSchema2 = _interopRequireDefault(_zSchema);

var _annotations = require('./annotations');

var _annotations2 = _interopRequireDefault(_annotations);

var _generator = require('./generator');

var _uriTemplate = require('./uri-template');

var _uriTemplate2 = _interopRequireDefault(_uriTemplate);

var _link = require('./link');

var _headers = require('./headers');

var _ast = require('./ast');

var _ast2 = _interopRequireDefault(_ast);

var _schema = require('./schema');

var _schema2 = _interopRequireDefault(_schema);

var _mediaType = require('./media-type');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Provide a `nextTick` function that either is Node's nextTick or a fallback
// for browsers
function nextTick(cb) {
  if (process && process.nextTick) {
    process.nextTick(cb);
  } else {
    cb();
  }
}

// Test whether a key is a special Swagger extension.
// The main Swagger parsing component that outputs refract.

function isExtension(value, key) {
  return _lodash2.default.startsWith(key, 'x-');
}

// The parser holds state about the current parsing environment and converts
// the input Swagger into Refract elements. The `parse` function is its main
// interface.

var Parser = function () {
  function Parser(_ref) {
    var minim = _ref.minim,
        source = _ref.source,
        generateSourceMap = _ref.generateSourceMap;
    (0, _classCallCheck3.default)(this, Parser);

    // Parser options
    this.minim = minim;
    this.source = source;
    this.generateSourceMap = generateSourceMap;

    // Global scheme requirements
    this.globalSchemes = [];

    // Loaded, dereferenced Swagger API
    this.swagger = null;
    // Refract parse result
    this.result = null;
    // Refract API category
    this.api = null;
    // State of the current parsing path
    this.path = [];
    // Current resource group, if any
    this.group = null;
  }

  (0, _createClass3.default)(Parser, [{
    key: 'parse',
    value: function parse(done) {
      var _this = this;

      var _minim$elements = this.minim.elements,
          Category = _minim$elements.Category,
          ParseResult = _minim$elements.ParseResult,
          SourceMap = _minim$elements.SourceMap;

      var swaggerParser = new _swaggerParser2.default();

      this.result = new ParseResult();

      // First, we load the YAML if it is a string, and handle any errors.
      var loaded = void 0;
      try {
        loaded = _lodash2.default.isString(this.source) ? _jsYaml2.default.safeLoad(this.source) : this.source;
      } catch (err) {
        // Temporarily disable generateSourceMap while handling error
        // This is because while handling this error we may try to generate
        // source map which further tries to parse YAML to get source
        // maps which causes another warning and raise conditions where we throw
        // an error back to the caller.
        var generateSourceMap = this.generateSourceMap;

        this.generateSourceMap = false;

        this.createAnnotation(_annotations2.default.CANNOT_PARSE, null, err.reason || 'Problem loading the input');

        if (err.mark) {
          this.result.first.attributes.set('sourceMap', [new SourceMap([[err.mark.position, 1]])]);
        }

        this.generateSourceMap = generateSourceMap;
        return done(new Error(err.message), this.result);
      }

      // Some sane defaults since these are sometimes left out completely
      if (loaded.info === undefined) {
        loaded.info = {};
      }

      if (loaded.paths === undefined) {
        loaded.paths = {};
      }

      // Next, we dereference and validate the loaded Swagger object. Any schema
      // violations get converted into annotations with source maps.
      var swaggerOptions = {
        $refs: {
          external: false
        }
      };

      return swaggerParser.validate(loaded, swaggerOptions, function (err) {
        var swagger = swaggerParser.api;
        _this.swagger = swaggerParser.api;

        if (err) {
          if (_this.swagger === undefined) {
            return done(err, _this.result);
          }

          // Non-fatal errors, so let us try and create annotations for them and
          // continue with the parsing as best we can.
          if (err.details) {
            var _ret = function () {
              var queue = [err.details];

              while (queue.length) {
                _lodash2.default.forEach(queue[0], function (item) {
                  _this.createAnnotation(_annotations2.default.VALIDATION_ERROR, item.path, item.message);

                  if (item.inner) {
                    // TODO: I am honestly not sure what the correct behavior is
                    // here. Some items will have within them a tree of other items,
                    // some of which might contain more info (but it's unclear).
                    // Do we treat them as their own error or do something else?
                    queue.push(item.inner);
                  }
                });

                queue.shift();
              }

              return {
                v: done(new Error(err.message), _this.result)
              };
            }();

            if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
          }

          // Maybe there is some information in the error itself? Let's check
          // whether it is a messed up reference!
          var location = null;
          var matches = err.message.match(/\$ref pointer "(.*?)"/);

          if (matches) {
            location = [_this.source.indexOf(matches[1]), matches[1].length];
          }

          var annotation = _this.createAnnotation(_annotations2.default.VALIDATION_ERROR, null, err.message);

          if (location !== null) {
            annotation.attributes.set('sourceMap', [new SourceMap([location])]);
          }

          return done(new Error(err.message), _this.result);
        }

        try {
          // Root API Element
          _this.api = new Category();
          _this.api.classes.push('api');
          _this.result.push(_this.api);

          // By default there are no groups, just the root API element
          _this.group = _this.api;

          _this.handleSwaggerInfo();
          _this.handleSwaggerHost();
          _this.handleSwaggerAuth();

          _this.handleExternalDocs(_this.api, swagger.externalDocs);

          _this.validateProduces(_this.swagger.produces);
          _this.validateConsumes(_this.swagger.consumes);

          var complete = function complete() {
            _this.handleSwaggerVendorExtensions(_this.api, swagger.paths);
            return done(null, _this.result);
          };

          // Swagger has a paths object to loop through that describes resources
          // We will run each path on it's own tick since it may take some time
          // and we want to ensure that other events in the event queue are not
          // held up.
          var paths = _lodash2.default.omitBy(swagger.paths, isExtension);
          var pendingPaths = (0, _keys2.default)(paths).length;

          if (pendingPaths === 0) {
            // If there are no paths, let's go ahead and call the callback.
            return complete();
          }

          return _lodash2.default.forEach(paths, function (pathValue, href) {
            nextTick(function () {
              _this.handleSwaggerPath(pathValue, href);
              pendingPaths -= 1;

              if (pendingPaths === 0) {
                // Last path, let's call the completion callback.
                complete();
              }
            });
          });
        } catch (exception) {
          _this.createAnnotation(_annotations2.default.UNCAUGHT_ERROR, null, 'There was a problem converting the Swagger document');

          return done(exception, _this.result);
        }
      });
    }

    // == Internal properties & functions ==

    // Base path (URL) name for the API

  }, {
    key: 'withPath',


    // This method lets you set the current parsing path and synchronously run
    // a function (e.g. to create an element).
    value: function withPath() {
      var i = void 0;
      var originalPath = _lodash2.default.clone(this.path);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (i = 0; i < args.length - 1; i += 1) {
        if (args[i] === '..') {
          this.path.pop();
        } else if (args[i] === '.') {
          // do nothing
        } else {
          this.path.push(args[i]);
        }
      }

      args[args.length - 1].bind(this)(this.path);

      this.path = originalPath;
    }

    // This is like `withPath` above, but slices the path before calling by
    // using the first argument as a length (starting at index 0).

  }, {
    key: 'withSlicedPath',
    value: function withSlicedPath() {
      var original = this.path.slice(0);

      // First, we slice the path, then call `withPath` and finally reset the path.

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.path = this.path.slice(0, args[0]);
      this.withPath.apply(this, (0, _toConsumableArray3.default)(args.slice(1)));
      this.path = original;
    }
  }, {
    key: 'handleExternalDocs',
    value: function handleExternalDocs(element, docs) {
      if (!docs) {
        return;
      }

      (0, _link.baseLink)(element, this, 'help', {
        description: docs.description,
        url: docs.url,
        path: this.path.concat(['externalDocs'])
      });
    }

    // Converts the Swagger title and description

  }, {
    key: 'handleSwaggerInfo',
    value: function handleSwaggerInfo() {
      var _this2 = this;

      var Copy = this.minim.elements.Copy;


      if (this.swagger.info) {
        this.withPath('info', function () {
          if (_this2.swagger.info.title) {
            _this2.withPath('title', function () {
              _this2.api.title = _this2.swagger.info.title;

              if (_this2.generateSourceMap) {
                _this2.createSourceMap(_this2.api.meta.get('title'), _this2.path);
              }

              return _this2.api.meta.get('title');
            });
          }

          if (_this2.swagger.info.description) {
            _this2.withPath('description', function () {
              var description = new Copy(_this2.swagger.info.description);
              _this2.api.content.push(description);

              if (_this2.generateSourceMap) {
                _this2.createSourceMap(description, _this2.path);
              }

              return description;
            });
          }

          _this2.handleSwaggerVendorExtensions(_this2.api, _this2.swagger.info);
        });
      }
    }

    // Converts the Swagger hostname and schemes to a Refract host metadata entry.

  }, {
    key: 'handleSwaggerHost',
    value: function handleSwaggerHost() {
      var _this3 = this;

      var MemberElement = this.minim.elements.Member;


      if (this.swagger.host) {
        this.withPath('host', function () {
          var hostname = _this3.swagger.host;

          if (_this3.swagger.schemes) {
            if (_this3.swagger.schemes.length > 1) {
              _this3.createAnnotation(_annotations2.default.DATA_LOST, ['schemes'], 'Only the first scheme will be used to create a hostname');
            }

            hostname = _this3.swagger.schemes[0] + '://' + hostname;
          }

          var metadata = [];
          var member = new MemberElement('HOST', hostname);

          member.meta.set('classes', ['user']);

          if (_this3.generateSourceMap) {
            _this3.createSourceMap(member, _this3.path);
          }

          metadata.push(member);
          _this3.api.attributes.set('metadata', metadata);

          return member;
        });
      }
    }

    // Conver api key name into Refract elements

  }, {
    key: 'apiKeyName',
    value: function apiKeyName(element, apiKey) {
      var MemberElement = this.minim.elements.Member;

      var config = void 0;

      if (apiKey.in === 'query') {
        config = 'queryParameterName';
      } else if (apiKey.in === 'header') {
        config = 'httpHeaderName';
      }

      var member = new MemberElement(config, apiKey.name);

      if (this.generateSourceMap) {
        this.createSourceMap(member, this.path.concat(['name']));
      }

      element.content.push(member);
    }

    // Convert Oauth2 flow into Refract elements

  }, {
    key: 'oauthGrantType',
    value: function oauthGrantType(element, flow) {
      var MemberElement = this.minim.elements.Member;

      var grantType = flow;

      if (flow === 'password') {
        grantType = 'resource owner password credentials';
      } else if (flow === 'application') {
        grantType = 'client credentials';
      } else if (flow === 'accessCode') {
        grantType = 'authorization code';
      }

      var member = new MemberElement('grantType', grantType);

      if (this.generateSourceMap) {
        this.createSourceMap(member, this.path.concat(['flow']));
      }

      element.content.push(member);
    }

    // Convert OAuth2 scopes into Refract elements

  }, {
    key: 'oauthScopes',
    value: function oauthScopes(element, items) {
      var _this4 = this;

      var _minim$elements2 = this.minim.elements,
          MemberElement = _minim$elements2.Member,
          ArrayElement = _minim$elements2.Array,
          StringElement = _minim$elements2.String;


      var scopes = new ArrayElement();
      var descriptions = null;
      var scopesList = items;

      if (_lodash2.default.isObject(items) && !_lodash2.default.isArray(items)) {
        descriptions = (0, _values2.default)(items);
        scopesList = (0, _keys2.default)(items);
      }

      // If value is not an empty array, then they are scopes
      _lodash2.default.forEach(scopesList, function (scopeName, index) {
        var scope = new StringElement(scopeName);

        if (descriptions) {
          scope.description = descriptions[index];

          if (_this4.generateSourceMap) {
            _this4.createSourceMap(scope.meta.get('description'), _this4.path.concat([scopeName]));
          }
        }

        if (_this4.generateSourceMap) {
          var value = descriptions ? scopeName : index;
          _this4.createSourceMap(scope, _this4.path.concat([value]));
        }

        scopes.content.push(scope);
      });

      if (scopes.length) {
        element.content.push(new MemberElement('scopes', scopes));
      }
    }

    // Conver OAuth2 transition information into Refract elements

  }, {
    key: 'oauthTransitions',
    value: function oauthTransitions(element, oauth) {
      var Transition = this.minim.elements.Transition;


      if (oauth.authorizationUrl) {
        var transition = new Transition();

        transition.relation = 'authorize';
        transition.href = oauth.authorizationUrl;

        if (this.generateSourceMap) {
          this.createSourceMap(transition.attributes.get('href'), this.path.concat(['authorizationUrl']));
          this.createSourceMap(transition.attributes.get('relation'), this.path.concat(['authorizationUrl']));
        }

        element.content.push(transition);
      }

      if (oauth.tokenUrl) {
        var _transition = new Transition();

        _transition.relation = 'token';
        _transition.href = oauth.tokenUrl;

        if (this.generateSourceMap) {
          this.createSourceMap(_transition.attributes.get('href'), this.path.concat(['tokenUrl']));
          this.createSourceMap(_transition.attributes.get('relation'), this.path.concat(['tokenUrl']));
        }

        element.content.push(_transition);
      }
    }

    // Convert a Swagger auth object into Refract elements.

  }, {
    key: 'handleSwaggerAuth',
    value: function handleSwaggerAuth() {
      var _this5 = this;

      var _minim$elements3 = this.minim.elements,
          Category = _minim$elements3.Category,
          AuthScheme = _minim$elements3.AuthScheme;

      var schemes = [];

      if (this.swagger.securityDefinitions) {
        _lodash2.default.keys(this.swagger.securityDefinitions).forEach(function (name) {
          _this5.withPath('securityDefinitions', name, function () {
            var item = _this5.swagger.securityDefinitions[name];
            var element = new AuthScheme();

            switch (item.type) {
              case 'basic':
                element.element = 'Basic Authentication Scheme';
                break;

              case 'apiKey':
                element.element = 'Token Authentication Scheme';
                _this5.apiKeyName(element, item);
                break;

              case 'oauth2':
                element.element = 'OAuth2 Scheme';
                _this5.oauthGrantType(element, item.flow);

                if (item.scopes) {
                  _this5.withPath('scopes', function () {
                    _this5.oauthScopes(element, item.scopes);
                  });
                }

                _this5.oauthTransitions(element, item);
                break;

              default:
                break;
            }

            element.id = name;

            if (_this5.generateSourceMap) {
              _this5.createSourceMap(element.meta.get('id'), _this5.path);
            }

            if (item['x-summary']) {
              element.title = item['x-summary'];

              if (_this5.generateSourceMap) {
                _this5.createSourceMap(element.meta.get('title'), _this5.path.concat(['x-summary']));
              }
            }

            if (item.description) {
              element.description = item.description;

              if (_this5.generateSourceMap) {
                _this5.createSourceMap(element.meta.get('description'), _this5.path.concat(['description']));
              }
            }

            schemes.push(element);
          });
        });
      }

      if (schemes.length) {
        var category = new Category();

        category.meta.set('classes', ['authSchemes']);
        category.content = schemes;

        this.api.content.push(category);
      }

      if (!this.swagger.security) {
        return;
      }

      this.handleSwaggerSecurity(this.swagger.security, this.globalSchemes);
    }
  }, {
    key: 'handleSwaggerSecurity',
    value: function handleSwaggerSecurity(security, schemes) {
      var _this6 = this;

      var AuthScheme = this.minim.elements.AuthScheme;


      _lodash2.default.forEach(security, function (item, index) {
        _lodash2.default.keys(item).forEach(function (name) {
          _this6.withPath('security', index, name, function () {
            var element = new AuthScheme();

            // If value is not an empty array, then they are scopes
            _this6.oauthScopes(element, item[name]);

            if (_this6.generateSourceMap) {
              _this6.createSourceMap(element, _this6.path);
            }

            element.element = name;
            schemes.push(element);
          });
        });
      });
    }
  }, {
    key: 'handleSwaggerTransitionAuth',
    value: function handleSwaggerTransitionAuth(methodValue) {
      var schemes = [];

      if (!methodValue.security) {
        return this.globalSchemes;
      }

      this.handleSwaggerSecurity(methodValue.security, schemes);

      return schemes;
    }

    // Convert a Swagger path into a Refract resource.

  }, {
    key: 'handleSwaggerPath',
    value: function handleSwaggerPath(pathValue, href) {
      var _this7 = this;

      var _minim$elements4 = this.minim.elements,
          Copy = _minim$elements4.Copy,
          Resource = _minim$elements4.Resource;

      var resource = new Resource();

      this.withPath('paths', href, function () {
        // Provide users with a way to add a title to a resource in Swagger
        if (pathValue['x-summary']) {
          _this7.withPath('x-summary', function () {
            resource.title = pathValue['x-summary'];

            if (_this7.generateSourceMap) {
              _this7.createSourceMap(resource.meta.get('title'), _this7.path);
            }

            return resource.meta.get('title');
          });
        }

        // Provide users a way to add a description to a resource in Swagger
        if (pathValue['x-description']) {
          _this7.withPath('x-description', function () {
            var resourceDescription = new Copy(pathValue['x-description']);
            resource.push(resourceDescription);

            if (_this7.generateSourceMap) {
              _this7.createSourceMap(resourceDescription, _this7.path);
            }

            return resourceDescription;
          });
        }

        if (_this7.useResourceGroups()) {
          _this7.updateResourceGroup(pathValue['x-group-name']);
        }

        _this7.group.content.push(resource);

        var pathObjectParameters = pathValue.parameters || [];
        var resourceHrefVariables = _this7.createHrefVariables(pathObjectParameters);

        if (resourceHrefVariables) {
          resource.hrefVariables = resourceHrefVariables;
        }

        // Set the resource-wide URI template, which can further be overridden
        // by individual transition URI templates. When creating a transition
        // below, we *only* set the transition URI template if it differs from
        // the one we've generated here.
        resource.href = (0, _uriTemplate2.default)(_this7.basePath, href, pathObjectParameters);

        if (_this7.generateSourceMap) {
          _this7.createSourceMap(resource.attributes.get('href'), _this7.path);
        }

        var relevantMethods = _lodash2.default.chain(pathValue).omit('parameters', '$ref').omitBy(isExtension).value();

        // Each path is an object with methods as properties
        _lodash2.default.forEach(relevantMethods, function (methodValue, method) {
          _this7.handleSwaggerMethod(resource, href, pathObjectParameters, methodValue, method);
        });

        _this7.handleSwaggerVendorExtensions(resource, pathValue);

        return resource;
      });
    }

    // Converts all unknown Swagger vendor extensions from an object into a API Element extension

  }, {
    key: 'handleSwaggerVendorExtensions',
    value: function handleSwaggerVendorExtensions(element, object) {
      var extensions = _lodash2.default.chain(object).pickBy(isExtension).omit('x-description', 'x-summary', 'x-group-name').value();

      if ((0, _keys2.default)(extensions).length > 0) {
        var _minim$elements5 = this.minim.elements,
            Link = _minim$elements5.Link,
            Extension = _minim$elements5.Extension;


        var profileLink = new Link();
        profileLink.relation = 'profile';
        profileLink.href = 'https://help.apiary.io/profiles/api-elements/vendor-extensions/';

        var extension = new Extension(extensions);
        extension.links = [profileLink];
        element.content.push(extension);
      }
    }

    // Convert a Swagger method into a Refract transition.

  }, {
    key: 'handleSwaggerMethod',
    value: function handleSwaggerMethod(resource, href, resourceParams, methodValue, method) {
      var _this8 = this;

      var _minim$elements6 = this.minim.elements,
          Copy = _minim$elements6.Copy,
          Transition = _minim$elements6.Transition;

      var transition = new Transition();

      resource.content.push(transition);

      this.withPath(method, function () {
        var schemes = _this8.handleSwaggerTransitionAuth(methodValue);

        _this8.validateProduces(methodValue.produces);
        _this8.validateConsumes(methodValue.consumes);

        _this8.handleExternalDocs(transition, methodValue.externalDocs);

        var transitionParams = methodValue.parameters || [];

        var queryParams = transitionParams.filter(function (parameter) {
          return parameter.in === 'query';
        });

        // Here we generate a URI template specific to this transition. If it
        // is different from the resource URI template, then we set the
        // transition's `href` attribute.
        var hrefForTransition = (0, _uriTemplate2.default)(_this8.basePath, href, resourceParams, queryParams);

        if (hrefForTransition !== resource.href.toValue()) {
          transition.href = hrefForTransition;
        }

        if (methodValue.summary) {
          _this8.withPath('summary', function () {
            transition.title = methodValue.summary;

            if (_this8.generateSourceMap) {
              _this8.createSourceMap(transition.meta.get('title'), _this8.path);
            }

            return transition.meta.get('title');
          });
        }

        if (methodValue.description) {
          _this8.withPath('description', function () {
            var description = new Copy(methodValue.description);
            transition.push(description);

            if (_this8.generateSourceMap) {
              _this8.createSourceMap(description, _this8.path);
            }

            return description;
          });
        }

        if (methodValue.operationId) {
          // TODO: Add a source map?
          transition.id = methodValue.operationId;
        }

        // For each uriParameter, create an hrefVariable
        var methodHrefVariables = _this8.createHrefVariables(transitionParams);
        if (methodHrefVariables) {
          transition.hrefVariables = methodHrefVariables;
        }

        // Currently, default responses are not supported in API Description format
        var relevantResponses = _lodash2.default.chain(methodValue.responses).omit('default').omitBy(isExtension).value();

        if (methodValue.responses && methodValue.responses.default) {
          _this8.withPath('responses', 'default', function (path) {
            _this8.createAnnotation(_annotations2.default.DATA_LOST, path, 'Default response is not yet supported');
          });
        }

        if (_lodash2.default.keys(relevantResponses).length === 0) {
          if (transitionParams.filter(function (p) {
            return p.in === 'body';
          }).length) {
            // Create an empty successful response so that the request/response
            // pair gets properly generated. In the future we may want to
            // refactor the code below as this is a little weird.
            relevantResponses.null = {};
          } else {
            _this8.createTransaction(transition, method, schemes.map(function (element) {
              return element.clone();
            }));
          }
        }

        // Transactions are created for each response in the document
        _lodash2.default.forEach(relevantResponses, function (responseValue, statusCode) {
          _this8.handleSwaggerResponse(transition, method, methodValue, transitionParams, responseValue, statusCode, schemes.map(function (element) {
            return element.clone();
          }), resourceParams);
        });

        _this8.handleSwaggerVendorExtensions(transition, methodValue);

        return transition;
      });
    }

    // Returns all of the content types for a request
    // Request content types include all consumes types
    // Returns `[null]` when there are no content types

  }, {
    key: 'gatherRequestContentTypes',
    value: function gatherRequestContentTypes(methodValue) {
      var contentTypes = (methodValue.consumes || this.swagger.consumes || []).filter(_mediaType.isValidContentType);

      if (contentTypes.length === 0) {
        return [null];
      }

      return contentTypes;
    }

    // Returns all of the content types for a response
    // Response content types include all example types OR the first JSON content type
    // Returns `[null]` when there are no content types

  }, {
    key: 'gatherResponseContentTypes',
    value: function gatherResponseContentTypes(methodValue, examples) {
      var contentTypes = [];

      if (examples && (0, _keys2.default)(examples).length > 0) {
        contentTypes = (0, _keys2.default)(examples);
      } else {
        var produces = methodValue.produces || this.swagger.produces || [];
        var jsonContentTypes = produces.filter(_mediaType.isJsonContentType);

        if (jsonContentTypes.length > 0) {
          contentTypes = [jsonContentTypes[0]];
        }
      }

      contentTypes = contentTypes.filter(_mediaType.isValidContentType);

      if (contentTypes.length === 0) {
        return [null];
      }

      return contentTypes;
    }

    // Convert a Swagger response & status code into Refract transactions.

  }, {
    key: 'handleSwaggerResponse',
    value: function handleSwaggerResponse(transition, method, methodValue, transitionParams, responseValue, statusCode, schemes, resourceParams) {
      var _this9 = this;

      var requestContentTypes = this.gatherRequestContentTypes(methodValue);
      var responseContentTypes = this.gatherResponseContentTypes(methodValue, responseValue.examples);

      responseContentTypes.forEach(function (responseContentType) {
        var responseBody = void 0;

        if (responseContentType && responseValue.examples && responseValue.examples[responseContentType]) {
          responseBody = responseValue.examples[responseContentType];
        }

        requestContentTypes.forEach(function (requestContentType) {
          var transaction = _this9.createTransaction(transition, method, schemes);

          _this9.handleSwaggerExampleRequest(transaction, methodValue, transitionParams, resourceParams, requestContentType, responseContentType, responseBody === undefined);

          _this9.handleSwaggerExampleResponse(transaction, methodValue, responseValue, statusCode, responseBody, responseContentType);
        });
      });
    }

    // Convert a Swagger example into a Refract request.

  }, {
    key: 'handleSwaggerExampleRequest',
    value: function handleSwaggerExampleRequest(transaction, methodValue, transitionParams, resourceParams, requestContentType, responseContentType, contentTypeFromProduces) {
      var _this10 = this;

      var contentType = requestContentType;
      var request = transaction.request;


      this.withPath(function () {
        var consumeIsJson = contentType && (0, _mediaType.isJsonContentType)(contentType);
        var consumeIsMultipartFormData = contentType && (0, _mediaType.isMultiPartFormData)(contentType);

        if (consumeIsMultipartFormData && !(0, _mediaType.hasBoundary)(contentType)) {
          // When multipart/form-data conntent type doesn't have a boundary
          // add a default one `BOUNDARY` which hopefully isn't found
          // in an example content. `parseBoundary` will provide the default.
          contentType += '; boundary=' + (0, _mediaType.parseBoundary)(contentType);
        }

        if (contentType) {
          (0, _headers.pushHeader)('Content-Type', contentType, request, _this10, 'consumes-content-type');
        }

        if (responseContentType) {
          if (contentTypeFromProduces) {
            (0, _headers.pushHeader)('Accept', responseContentType, request, _this10, 'produces-accept');
          } else {
            (0, _headers.pushHeader)('Accept', responseContentType, request, _this10);
          }
        }

        var formParams = [];
        var formParamsSchema = { type: 'object', properties: {}, required: [] };

        var parametersGenerator = {};

        _lodash2.default.forEach([[resourceParams, '..'], [transitionParams, '.']], function (parameters) {
          _lodash2.default.forEach(parameters[0], function (param, index) {
            switch (param.in) {
              case 'header':
                _lodash2.default.set(parametersGenerator, [param.in, param.name], _lodash2.default.bind(_this10.withPath, _this10, parameters[1], 'parameters', index, function () {
                  (0, _headers.pushHeaderObject)(param.name, param, request, _this10);
                }));
                break;

              case 'body':
                _lodash2.default.set(parametersGenerator, [param.in, param.name], _lodash2.default.bind(_this10.withPath, _this10, parameters[1], 'parameters', index, function () {
                  if (param['x-example']) {
                    _this10.withPath('x-example', function () {
                      _this10.createAnnotation(_annotations2.default.VALIDATION_ERROR, _this10.path, 'The \'x-example\' property isn\'t allowed for body parameters - use \'schema.example\' instead');
                    });
                  }

                  _this10.withPath('schema', function () {
                    if (consumeIsJson) {
                      (0, _generator.bodyFromSchema)(param.schema, request, _this10, contentType);
                    }

                    _this10.pushSchemaAsset(param.schema, request, _this10.path);
                  });
                }));
                break;

              case 'formData':
                _lodash2.default.set(parametersGenerator, [param.in, param.name], _lodash2.default.bind(_this10.withPath, _this10, parameters[1], 'parameters', index, function () {
                  _this10.formDataParameterCheck(param);
                  formParamsSchema = (0, _generator.bodyFromFormParameter)(param, formParamsSchema);
                  var member = _this10.convertParameterToMember(param);
                  formParams.push(member);
                }));
                break;

              default:
            }
          });
        });

        _lodash2.default.forEach(parametersGenerator, function (paramType) {
          _lodash2.default.forEach(paramType, function (invoke) {
            invoke();
          });
        });

        if (!contentType || consumeIsMultipartFormData || (0, _mediaType.isFormURLEncoded)(contentType)) {
          _this10.generateFormParameters(formParams, formParamsSchema, request, contentType);
        }

        // Using form parameters instead of body? We will convert those to
        // data structures and will generate form-urlencoded body.
        return request;
      });
    }
  }, {
    key: 'generateFormParameters',
    value: function generateFormParameters(parameters, schema, request, contentType) {
      if (_lodash2.default.isEmpty(parameters)) {
        return;
      }

      var _minim$elements7 = this.minim.elements,
          DataStructure = _minim$elements7.DataStructure,
          ObjectElement = _minim$elements7.Object;


      if (!contentType) {
        // No content type was provided, lets default to first form
        (0, _headers.pushHeader)('Content-Type', _mediaType.FORM_CONTENT_TYPE, request, this, 'form-data-content-type');
      }

      (0, _generator.bodyFromSchema)(schema, request, this, contentType || _mediaType.FORM_CONTENT_TYPE);

      // Generating data structure
      var dataStructure = new DataStructure();

      // A form is essentially an object with key/value members
      var dataObject = new ObjectElement();

      _lodash2.default.forEach(parameters, function (param) {
        dataObject.content.push(param);
      });

      dataStructure.content = dataObject;
      request.content.push(dataStructure);
    }
  }, {
    key: 'formDataParameterCheck',
    value: function formDataParameterCheck(param) {
      if (param.type === 'array') {
        this.createAnnotation(_annotations2.default.DATA_LOST, this.path, 'Arrays in form parameters are not fully supported yet');

        return;
      }

      if (param.allowEmptyValue) {
        this.createAnnotation(_annotations2.default.DATA_LOST, this.path, 'The allowEmptyValue flag is not fully supported yet');
      }
    }

    // Convert a Swagger example into a Refract response.

  }, {
    key: 'handleSwaggerExampleResponse',
    value: function handleSwaggerExampleResponse(transaction, methodValue, responseValue, statusCode, responseBody, contentType) {
      var _this11 = this;

      var _minim$elements8 = this.minim.elements,
          Asset = _minim$elements8.Asset,
          Copy = _minim$elements8.Copy;
      var response = transaction.response;


      this.withPath('responses', statusCode, function () {
        if (responseValue.description) {
          var description = new Copy(responseValue.description);
          response.content.push(description);

          if (_this11.generateSourceMap) {
            _this11.createSourceMap(description, _this11.path.concat(['description']));
          }
        }

        if (contentType) {
          if (responseValue.examples && responseValue.examples[contentType]) {
            _this11.withPath('examples', contentType, function () {
              (0, _headers.pushHeader)('Content-Type', contentType, response, _this11);
            });
          } else {
            (0, _headers.pushHeader)('Content-Type', contentType, response, _this11, 'produces-content-type');
          }
        }

        var isJsonResponse = (0, _mediaType.isJsonContentType)(contentType);

        if (responseValue.headers) {
          _this11.updateHeaders(response, responseValue.headers);
        }

        _this11.withPath('examples', function () {
          // Responses can have bodies
          if (responseBody !== undefined) {
            _this11.withPath(contentType, function () {
              var formattedResponseBody = responseBody;
              var serialized = true;

              if (typeof responseBody !== 'string') {
                try {
                  formattedResponseBody = (0, _stringify2.default)(responseBody, null, 2);
                } catch (exception) {
                  _this11.createAnnotation(_annotations2.default.DATA_LOST, _this11.path, 'Circular references in examples are not yet supported.');
                  serialized = false;
                }
              }

              if (serialized) {
                var bodyAsset = new Asset(formattedResponseBody);
                bodyAsset.classes.push('messageBody');

                if (_this11.generateSourceMap) {
                  _this11.createSourceMap(bodyAsset, _this11.path);
                }

                response.content.push(bodyAsset);
              }
            });
          }

          // Responses can have schemas in Swagger
          var exampleSchema = responseValue.examples && responseValue.examples.schema;
          var schema = responseValue.schema || exampleSchema;

          if (schema) {
            var _args = void 0;

            if (responseValue.examples && responseValue.examples.schema) {
              _args = [5, 'examples', 'schema'];
            } else {
              _args = [5, 'schema'];
            }

            _this11.withSlicedPath.apply(_this11, (0, _toConsumableArray3.default)(_args.concat([function () {
              if (isJsonResponse && responseBody === undefined) {
                (0, _generator.bodyFromSchema)(schema, response, _this11, contentType);
              }

              _this11.pushSchemaAsset(schema, response, _this11.path);
            }])));
          }

          if (statusCode !== 'null') {
            response.statusCode = statusCode;

            if (_this11.generateSourceMap) {
              _this11.createSourceMap(response.attributes.get('statusCode'), _this11.path.slice(0, -1));
            }
          }
        });

        _this11.handleSwaggerVendorExtensions(response, responseValue);

        return response;
      });
    }

    // Takes in an `payload` element and a list of Swagger headers. Adds
    // the Swagger headers to the headers element in the payload

  }, {
    key: 'updateHeaders',
    value: function updateHeaders(payload, httpHeaders) {
      var _this12 = this;

      _lodash2.default.forEach(_lodash2.default.keys(httpHeaders), function (headerName) {
        if (Object.prototype.hasOwnProperty.call(httpHeaders, headerName)) {
          // eslint-disable-next-line no-loop-func
          _this12.withPath('headers', headerName, function () {
            (0, _headers.pushHeaderObject)(headerName, httpHeaders[headerName], payload, _this12);
          });
        }
      });
    }

    // Test whether tags can be treated as resource groups, and if so it sets a
    // group name for each resource (used later to create groups).

  }, {
    key: 'useResourceGroups',
    value: function useResourceGroups() {
      var tags = [];

      if (this.swagger.paths) {
        _lodash2.default.forEach(this.swagger.paths, function (path) {
          var tag = null;

          if (path) {
            var operations = _lodash2.default.omitBy(path, isExtension);

            // eslint-disable-next-line consistent-return
            _lodash2.default.forEach(operations, function (operation) {
              if (operation.tags && operation.tags.length) {
                if (operation.tags.length > 1) {
                  // Too many tags... each resource can only be in one group!
                  return false;
                }

                if (tag === null) {
                  var _operation$tags = (0, _slicedToArray3.default)(operation.tags, 1);

                  tag = _operation$tags[0];
                } else if (tag !== operation.tags[0]) {
                  // Non-matching tags... can't have a resource in multiple groups!
                  return false;
                }
              }
            });
          }

          if (tag) {
            // eslint-disable-next-line no-param-reassign
            path['x-group-name'] = tag;
            tags.push(tag);
          }
        });
      }

      return tags.length > 0;
    }

    // Update the current group by either selecting or creating it.

  }, {
    key: 'updateResourceGroup',
    value: function updateResourceGroup(name) {
      var _this13 = this;

      var _minim$elements9 = this.minim.elements,
          Category = _minim$elements9.Category,
          Copy = _minim$elements9.Copy;


      if (name) {
        this.group = this.api.find(function (el) {
          return el.element === 'category' && el.classes.contains('resourceGroup') && el.title.toValue() === name;
        }).first;

        if (!this.group) {
          // TODO: Source maps for these groups. The problem is that the location
          // may not always make sense. Do we point to the tag description,
          // the resource, or the transition?
          this.group = new Category();
          this.group.title = name;
          this.group.classes.push('resourceGroup');

          if (this.swagger.tags && _lodash2.default.isArray(this.swagger.tags)) {
            _lodash2.default.forEach(this.swagger.tags, function (tag) {
              if (tag.name === name && tag.description) {
                _this13.group.content.push(new Copy(tag.description));
              }

              _this13.handleExternalDocs(_this13.group, tag.externalDocs);
            });
          }

          this.api.content.push(this.group);
        }
      }
    }

    /* eslint-disable class-methods-use-this */

  }, {
    key: 'schemaForParameterValue',
    value: function schemaForParameterValue(parameter) {
      var schema = {
        type: parameter.type
      };

      if (schema.type === 'integer') {
        schema.type = 'number';
      }

      if (parameter.items) {
        schema.items = parameter.items;
      }

      return schema;
    }
  }, {
    key: 'typeForParameter',
    value: function typeForParameter(parameter) {
      var _minim$elements10 = this.minim.elements,
          ArrayElement = _minim$elements10.Array,
          BooleanElement = _minim$elements10.Boolean,
          NumberElement = _minim$elements10.Number,
          StringElement = _minim$elements10.String;


      var types = {
        string: StringElement,
        number: NumberElement,
        integer: NumberElement,
        boolean: BooleanElement,
        array: ArrayElement,
        file: StringElement
      };

      return types[parameter.type];
    }
  }, {
    key: 'convertValueToElement',
    value: function convertValueToElement(value, schema) {
      var _this14 = this;

      var validator = new _zSchema2.default();
      var element = void 0;

      if (validator.validate(value, schema)) {
        element = this.minim.toElement(value);

        if (this.generateSourceMap) {
          this.createSourceMap(element, this.path);
        }
      } else {
        validator.getLastError().details.forEach(function (detail) {
          _this14.createAnnotation(_annotations2.default.VALIDATION_WARNING, _this14.path, detail.message);
        });

        // Coerce parameter to correct type
        if (schema.type === 'string') {
          if (typeof value === 'number' || typeof value === 'boolean') {
            element = new this.minim.elements.String(String(value));
          }
        }
      }

      return element;
    }

    // Convert a Swagger parameter into a Refract element.

  }, {
    key: 'convertParameterToElement',
    value: function convertParameterToElement(parameter) {
      var _this15 = this;

      var setAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _minim$elements11 = this.minim.elements,
          ArrayElement = _minim$elements11.Array,
          EnumElement = _minim$elements11.Enum;


      var Type = this.typeForParameter(parameter);
      var schema = this.schemaForParameterValue(parameter);

      var element = new Type();

      if (parameter['x-example'] !== undefined) {
        this.withPath('x-example', function () {
          var value = _this15.convertValueToElement(parameter['x-example'], schema);

          if (value) {
            element = value;
          }
        });
      }

      if (parameter.enum) {
        if (element.toValue()) {
          element = new EnumElement(element);
        } else {
          element = new EnumElement();
        }

        var enumerations = new ArrayElement();

        parameter.enum.forEach(function (value, index) {
          _this15.withPath('enum', index, function () {
            var enumeration = _this15.convertValueToElement(value, schema);

            if (enumeration) {
              enumerations.push(enumeration);
            }
          });
        });

        element.enumerations = enumerations;
      }

      if (parameter.default) {
        this.withPath('default', function () {
          var value = _this15.convertValueToElement(parameter.default, schema);

          if (value) {
            if (parameter.enum) {
              value = new EnumElement(value);
            }

            element.attributes.set('default', value);
          }
        });
      }

      if (parameter.type === 'array' && parameter.items && element.content.length === 0) {
        this.withPath('items', function () {
          element.content = [_this15.convertParameterToElement(parameter.items, true)];
        });
      }

      if (this.generateSourceMap) {
        this.createSourceMap(element, this.path);
      }

      if (setAttributes) {
        if (parameter.description) {
          element.description = parameter.description;

          if (this.generateSourceMap) {
            this.createSourceMap(element.meta.get('description'), this.path.concat(['description']));
          }
        }

        if (parameter.required) {
          element.attributes.set('typeAttributes', ['required']);
        }
      }

      return element;
    }

    // Convert a Swagger parameter into a Refract member element for use in an
    // object element (or subclass).

  }, {
    key: 'convertParameterToMember',
    value: function convertParameterToMember(parameter) {
      var MemberElement = this.minim.getElementClass('member');
      var memberValue = this.convertParameterToElement(parameter);

      // TODO: Update when Minim has better support for elements as values
      // should be: new MemberType(parameter.name, memberValue);
      var member = new MemberElement(parameter.name);
      member.content.value = memberValue;

      if (this.generateSourceMap) {
        this.createSourceMap(member, this.path);
      }

      if (parameter.description) {
        member.description = parameter.description;

        if (this.generateSourceMap) {
          this.createSourceMap(member.meta.get('description'), this.path.concat(['description']));
        }
      }

      if (parameter.required) {
        member.attributes.set('typeAttributes', ['required']);
      }

      return member;
    }

    // Make a new source map for the given element

  }, {
    key: 'createSourceMap',
    value: function createSourceMap(element, path) {
      if (this.ast) {
        var SourceMap = this.minim.getElementClass('sourceMap');
        var position = this.ast.getPosition(path);

        // eslint-disable-next-line no-restricted-globals
        if (position && !isNaN(position.start) && !isNaN(position.end)) {
          element.attributes.set('sourceMap', [new SourceMap([[position.start, position.end - position.start]])]);
        }
      }
    }

    // Make a new annotation for the given path and message

  }, {
    key: 'createAnnotation',
    value: function createAnnotation(info, path, message) {
      var Annotation = this.minim.elements.Annotation;


      var annotation = new Annotation(message);
      annotation.classes.push(info.type);
      annotation.code = info.code;

      this.result.content.push(annotation);

      if (info.fragment) {
        (0, _link.origin)(info.fragment, annotation, this);
      }

      if (path && this.ast) {
        this.createSourceMap(annotation, path);
      }

      return annotation;
    }

    // Create a new HrefVariables element from a parameter list. Returns either
    // the new HrefVariables element or `undefined`.

  }, {
    key: 'createHrefVariables',
    value: function createHrefVariables(params) {
      var _this16 = this;

      var HrefVariables = this.minim.elements.HrefVariables;

      var hrefVariables = new HrefVariables();

      _lodash2.default.forEach(params, function (parameter, index) {
        _this16.withPath('parameters', index, function () {
          var member = void 0;
          var format = parameter.collectionFormat || 'csv';

          // Adding a warning if format is not supported
          if (!(['multi', 'csv'].indexOf(format) !== -1)) {
            _this16.createAnnotation(_annotations2.default.DATA_LOST, _this16.path, 'Parameters of collection format \'' + format + '\' are not supported');
          }

          if (parameter.in === 'query' || parameter.in === 'path') {
            member = _this16.convertParameterToMember(parameter);
            hrefVariables.content.push(member);
          }

          return member;
        });
      });

      return hrefVariables.length ? hrefVariables : undefined;
    }

    // Create a Refract asset element containing JSON Schema and push into payload

  }, {
    key: 'pushSchemaAsset',
    value: function pushSchemaAsset(schema, payload, path) {
      var handledSchema = false;
      var actualSchema = _lodash2.default.omit(schema, ['discriminator', 'readOnly', 'xml', 'externalDocs', 'example']);
      actualSchema = _lodash2.default.omitBy(actualSchema, isExtension);

      try {
        var Asset = this.minim.getElementClass('asset');
        var schemaAsset = new Asset((0, _stringify2.default)(actualSchema));

        schemaAsset.classes.push('messageBodySchema');
        schemaAsset.contentType = 'application/schema+json';

        if (this.generateSourceMap) {
          this.createSourceMap(schemaAsset, path);
        }

        this.handleExternalDocs(schemaAsset, schema.externalDocs);

        payload.content.push(schemaAsset);
        handledSchema = true;
      } catch (exception) {
        this.createAnnotation(_annotations2.default.DATA_LOST, path, 'Circular references in schema are not yet supported');
      }

      if (handledSchema) {
        try {
          var generator = new _schema2.default(this.minim);
          var dataStructure = generator.generateDataStructure(schema);
          if (dataStructure) {
            payload.content.push(dataStructure);
          }
        } catch (exception) {
          // TODO: Expose errors once feature is more-complete
        }
      }
    }

    // Create a new Refract transition element with a blank request and response.

  }, {
    key: 'createTransaction',
    value: function createTransaction(transition, method, schemes) {
      var _minim$elements12 = this.minim.elements,
          HttpRequest = _minim$elements12.HttpRequest,
          HttpResponse = _minim$elements12.HttpResponse,
          HttpTransaction = _minim$elements12.HttpTransaction;

      var transaction = new HttpTransaction();
      transaction.content = [new HttpRequest(), new HttpResponse()];

      if (transition) {
        transition.content.push(transaction);
      }

      if (method) {
        transaction.request.method = method.toUpperCase();

        if (this.generateSourceMap) {
          this.createSourceMap(transaction.request.attributes.get('method'), this.path);
        }
      }

      if (schemes.length) {
        transaction.attributes.set('authSchemes', schemes);
      }

      return transaction;
    }
  }, {
    key: 'validateProduces',
    value: function validateProduces(produces) {
      var _this17 = this;

      if (produces) {
        this.withPath('produces', function () {
          _this17.validateContentTypes(produces);
        });
      }
    }
  }, {
    key: 'validateConsumes',
    value: function validateConsumes(consumes) {
      var _this18 = this;

      if (consumes) {
        this.withPath('consumes', function () {
          _this18.validateContentTypes(consumes);
        });
      }
    }
  }, {
    key: 'validateContentTypes',
    value: function validateContentTypes(contentTypes) {
      var _this19 = this;

      contentTypes.forEach(function (contentType) {
        try {
          _mediaTyper2.default.parse(contentType);
        } catch (e) {
          var index = contentTypes.indexOf(contentType);
          _this19.withPath(index, function () {
            _this19.createAnnotation(_annotations2.default.VALIDATION_WARNING, _this19.path, 'Invalid content type \'' + contentType + '\', ' + e.message);
          });
        }
      });
    }
  }, {
    key: 'basePath',
    get: function get() {
      return (this.swagger.basePath || '').replace(/[/]+$/, '');
    }

    // Lazy-loaded input AST is made available when we need it. If it can't be
    // loaded, then an annotation is generated with more information about why.

  }, {
    key: 'ast',
    get: function get() {
      if (this.internalAST !== undefined) {
        return this.internalAST;
      }

      if (_lodash2.default.isString(this.source)) {
        try {
          this.internalAST = new _ast2.default(this.source);
        } catch (err) {
          this.internalAST = null;

          var message = 'YAML Syntax Error';
          if (err.problem) {
            message = message + ': ' + err.problem;
          }

          var annotation = this.createAnnotation(_annotations2.default.AST_UNAVAILABLE, null, message);

          if (err.problem_mark && err.problem_mark.pointer) {
            var SourceMap = this.minim.getElementClass('sourceMap');
            var position = err.problem_mark.pointer;

            annotation.attributes.set('sourceMap', [new SourceMap([[position, 1]])]);
          }
        }
      } else {
        this.internalAST = null;
        this.createAnnotation(_annotations2.default.AST_UNAVAILABLE, null, 'Source maps are only available with string input');
      }

      return this.internalAST;
    }
  }]);
  return Parser;
}();

exports.default = Parser;
//# sourceMappingURL=parser.map