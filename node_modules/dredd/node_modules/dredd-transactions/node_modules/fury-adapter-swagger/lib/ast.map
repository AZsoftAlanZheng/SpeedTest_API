{"version":3,"sources":["ast.js"],"names":["Ast","source","root","compose","path","pieces","isArray","concat","split","end","node","piece","shift","start","undefined","newNode","tag","value","subNode","length","start_mark","pointer","end_mark"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAGA;;;;AACA;;;;;;AAJA;AACA;;IAKqBA,G;AACnB,eAAYC,MAAZ,EAAoB;AAAA;;AAClB,SAAKC,IAAL,GAAY,iBAAQC,OAAR,CAAgBF,MAAhB,CAAZ;AACD;;AAED;AACA;AACA;AACA;;;;;gCACYG,I,EAAM;AAChB,UAAMC,SAAS,iBAAEC,OAAF,CAAUF,IAAV,IAAkB,GAAGG,MAAH,CAAUH,IAAV,CAAlB,GAAoCA,KAAKI,KAAL,CAAW,GAAX,CAAnD;AACA,UAAIC,YAAJ;AACA,UAAIC,OAAO,KAAKR,IAAhB;AACA,UAAIS,QAAQN,OAAOO,KAAP,EAAZ;AACA,UAAIC,cAAJ;;AAEA,UAAI,CAACH,IAAL,EAAW;AACT,eAAO,IAAP;AACD;;AAED,aAAOC,UAAUG,SAAjB,EAA4B;AAC1B,YAAIC,UAAU,IAAd;;AAEA,YAAIL,KAAKM,GAAL,KAAa,uBAAjB,EAA0C;AACxC;AACA;AAFwC;AAAA;AAAA;;AAAA;AAGxC,4DAAsBN,KAAKO,KAA3B,4GAAkC;AAAA,kBAAvBC,OAAuB;;AAChC,kBAAIA,QAAQ,CAAR,KAAcA,QAAQ,CAAR,EAAWD,KAAX,KAAqBN,KAAvC,EAA8C;AAAA,4DAC9BO,OAD8B;;AACzCH,uBADyC;;;AAG5C,oBAAI,CAACV,OAAOc,MAAZ,EAAoB;AAClB;AACAN,0BAAQK,QAAQ,CAAR,EAAWE,UAAX,CAAsBC,OAA9B;AACAZ,wBAAMS,QAAQ,CAAR,EAAWI,QAAX,CAAoBD,OAA1B;AACD;AACD;AACD;AACF;AAduC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAezC,SAfD,MAeO,IAAIX,KAAKM,GAAL,KAAa,uBAAjB,EAA0C;AAC/C;AACAD,oBAAUL,KAAKO,KAAL,CAAWN,KAAX,CAAV;;AAEA,cAAI,CAACN,OAAOc,MAAZ,EAAoB;AAClB;;AAEA,gBAAI,CAACJ,OAAD,IAAYJ,QAAQ,CAApB,IAAyBD,KAAKO,KAAL,CAAWN,QAAQ,CAAnB,CAA7B,EAAoD;AAClD;AACA;AACAE,sBAAQH,KAAKO,KAAL,CAAWN,QAAQ,CAAnB,EAAsBW,QAAtB,CAA+BD,OAAvC;AACAZ,oBAAMI,QAAQ,CAAd;AACD,aALD,MAKO;AACLA,sBAAQE,QAAQK,UAAR,CAAmBC,OAA3B;AACAZ,oBAAMM,QAAQO,QAAR,CAAiBD,OAAvB;AACD;AACF;AACF,SAjBM,MAiBA;AACL;AACA,iBAAO,IAAP;AACD;;AAED,YAAIN,OAAJ,EAAa;AACXL,iBAAOK,OAAP;AACD,SAFD,MAEO;AACL;AACA;AACA,iBAAO,EAAEF,YAAF,EAASJ,QAAT,EAAP;AACD;;AAEDE,gBAAQN,OAAOO,KAAP,EAAR;AACD;;AAED,aAAO,EAAEC,YAAF,EAASJ,QAAT,EAAP;AACD;;;;;kBAxEkBT,G","file":"ast.js","sourcesContent":["// A module for dealing with YAML syntax trees and looking up source map\n// location information.\n\nimport _ from 'lodash';\nimport yamlAst from 'yaml-js';\n\nexport default class Ast {\n  constructor(source) {\n    this.root = yamlAst.compose(source);\n  }\n\n  // Look up a position in the original source based on a JSON path, for\n  // example ['paths', '/test', 'get', 'responses', '200']. Also supported\n  // is using a string ('paths./test.get') but it does not understand any\n  // escaping.\n  getPosition(path) {\n    const pieces = _.isArray(path) ? [].concat(path) : path.split('.');\n    let end;\n    let node = this.root;\n    let piece = pieces.shift();\n    let start;\n\n    if (!node) {\n      return null;\n    }\n\n    while (piece !== undefined) {\n      let newNode = null;\n\n      if (node.tag === 'tag:yaml.org,2002:map') {\n        // This is a may / object with key:value pairs.\n        // eslint-disable-next-line no-restricted-syntax\n        for (const subNode of node.value) {\n          if (subNode[0] && subNode[0].value === piece) {\n            [, newNode] = subNode;\n\n            if (!pieces.length) {\n              // This is the last item!\n              start = subNode[0].start_mark.pointer;\n              end = subNode[1].end_mark.pointer;\n            }\n            break;\n          }\n        }\n      } else if (node.tag === 'tag:yaml.org,2002:seq') {\n        // This is a sequence, i.e. array. Access it by index.\n        newNode = node.value[piece];\n\n        if (!pieces.length) {\n          // This is the last item!\n\n          if (!newNode && piece > 0 && node.value[piece - 1]) {\n            // Element in sequence does not exist. It could have been empty\n            // Let's provide the end of previous element\n            start = node.value[piece - 1].end_mark.pointer;\n            end = start + 1;\n          } else {\n            start = newNode.start_mark.pointer;\n            end = newNode.end_mark.pointer;\n          }\n        }\n      } else {\n        // Unknown piece, which will just return no source map.\n        return null;\n      }\n\n      if (newNode) {\n        node = newNode;\n      } else {\n        // We have no other node so return whatever we have.\n        // Better than nothing init?\n        return { start, end };\n      }\n\n      piece = pieces.shift();\n    }\n\n    return { start, end };\n  }\n}\n"]}