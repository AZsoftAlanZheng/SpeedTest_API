{"version":3,"sources":["fury.js"],"names":["minim","namespace","use","findAdapter","adapters","mediaType","method","i","length","mediaTypes","indexOf","Fury","adapter","push","elements","fromRefract","source","filter","detect","done","adapterOptions","parse","err","result","annotations","ParseResult","parseResult","options","Object","assign","validate","Element","load","generateSourceMap","Error","api","serialize","fury"],"mappings":"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","file":"fury.js","sourcesContent":["import minimModule from 'minim';\nimport minimParseResult from 'minim-parse-result';\n\nconst minim = minimModule.namespace()\n  .use(minimParseResult);\n\n/*\n * Find an adapter by a given media type and method name, which should be\n * either `parse` or `serialize`. If no adapter is found, then\n * undefined is returned.\n */\nfunction findAdapter(adapters, mediaType, method) {\n  for (let i = 0; i < adapters.length; i += 1) {\n    if (adapters[i].mediaTypes.indexOf(mediaType) !== -1 && adapters[i][method]) {\n      return adapters[i];\n    }\n  }\n\n  return null;\n}\n\nclass Fury {\n  constructor() {\n    this.minim = minim;\n    this.adapters = [];\n  }\n\n  /*\n   * Register to use an adapter with this Fury instance.\n   */\n  use(adapter) {\n    this.adapters.push(adapter);\n    return this;\n  }\n\n  /*\n   * Load serialized refract elements into Javascript objects.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  load(elements) {\n    return this.minim.fromRefract(elements);\n  }\n\n  // Returns an array of adapters which can handle the given API Description Source\n  detect(source) {\n    return this.adapters.filter(adapter => adapter.detect && adapter.detect(source));\n  }\n\n  findAdapter(source, mediaType, method) {\n    if (mediaType) {\n      return findAdapter(this.adapters, mediaType, method);\n    }\n\n    return this.detect(source).filter(adapter => adapter[method])[0];\n  }\n\n  validate({ source, mediaType, adapterOptions }, done) {\n    const adapter = this.findAdapter(source, mediaType, 'validate');\n\n    if (!adapter) {\n      return this.parse({ source, mediaType, adapterOptions }, (err, result) => {\n        if (result && result.annotations.length > 0) {\n          const { ParseResult } = this.minim.elements;\n          const parseResult = new ParseResult(result.annotations);\n          done(err, parseResult);\n        } else {\n          done(err, null);\n        }\n      });\n    }\n\n    let options = { minim: this.minim, source };\n\n    if (adapterOptions) {\n      options = Object.assign(options, adapterOptions);\n    }\n\n    return adapter.validate(options, (err, elements) => {\n      if (!elements || elements instanceof this.minim.Element) {\n        done(err, elements);\n      } else {\n        done(err, this.load(elements));\n      }\n    });\n  }\n\n  /*\n   * Parse an input document into Javascript objects. This method uses\n   * the registered adapters to automatically detect the input format,\n   * then uses the adapter to convert into refract elements and loads\n   * these into objects.\n   */\n  parse({\n    source, mediaType, generateSourceMap = false, adapterOptions,\n  }, done) {\n    const adapter = this.findAdapter(source, mediaType, 'parse');\n\n    if (!adapter) {\n      return done(new Error('Document did not match any registered parsers!'));\n    }\n\n    try {\n      let options = { generateSourceMap, minim: this.minim, source };\n\n      if (adapterOptions) {\n        options = Object.assign(options, adapterOptions);\n      }\n\n      return adapter.parse(options, (err, elements) => {\n        if (!elements || elements instanceof this.minim.Element) {\n          done(err, elements);\n        } else {\n          done(err, this.load(elements));\n        }\n      });\n    } catch (err) {\n      return done(err);\n    }\n  }\n\n  /*\n   * Serialize a parsed API into the given output format.\n   */\n  serialize({ api, mediaType = 'text/vnd.apiblueprint' }, done) {\n    const adapter = findAdapter(this.adapters, mediaType, 'serialize');\n\n    if (adapter) {\n      try {\n        return adapter.serialize({ api, minim: this.minim }, done);\n      } catch (err) {\n        return done(err);\n      }\n    } else {\n      return done(new Error('Media type did not match any registered serializer!'));\n    }\n  }\n}\n\n/*\n  Since we need to provide a sane interface to both ES6 `import` and\n  normal Node.js `require` statements, we make a single default export\n  and set up some other faux exports within it. See Babel's module\n  docs: https://babeljs.io/docs/usage/modules/.\n*/\nconst fury = new Fury();\n\nfury.Fury = Fury;\n\nexport default fury;\n"]}