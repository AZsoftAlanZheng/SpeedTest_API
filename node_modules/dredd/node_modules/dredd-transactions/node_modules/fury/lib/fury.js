'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _minim = require('minim');

var _minim2 = _interopRequireDefault(_minim);

var _minimParseResult = require('minim-parse-result');

var _minimParseResult2 = _interopRequireDefault(_minimParseResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var minim = _minim2.default.namespace().use(_minimParseResult2.default);

/*
 * Find an adapter by a given media type and method name, which should be
 * either `parse` or `serialize`. If no adapter is found, then
 * undefined is returned.
 */
function _findAdapter(adapters, mediaType, method) {
  for (var i = 0; i < adapters.length; i += 1) {
    if (adapters[i].mediaTypes.indexOf(mediaType) !== -1 && adapters[i][method]) {
      return adapters[i];
    }
  }

  return null;
}

var Fury = function () {
  function Fury() {
    _classCallCheck(this, Fury);

    this.minim = minim;
    this.adapters = [];
  }

  /*
   * Register to use an adapter with this Fury instance.
   */


  _createClass(Fury, [{
    key: 'use',
    value: function use(adapter) {
      this.adapters.push(adapter);
      return this;
    }

    /*
     * Load serialized refract elements into Javascript objects.
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'load',
    value: function load(elements) {
      return this.minim.fromRefract(elements);
    }

    // Returns an array of adapters which can handle the given API Description Source

  }, {
    key: 'detect',
    value: function detect(source) {
      return this.adapters.filter(function (adapter) {
        return adapter.detect && adapter.detect(source);
      });
    }
  }, {
    key: 'findAdapter',
    value: function findAdapter(source, mediaType, method) {
      if (mediaType) {
        return _findAdapter(this.adapters, mediaType, method);
      }

      return this.detect(source).filter(function (adapter) {
        return adapter[method];
      })[0];
    }
  }, {
    key: 'validate',
    value: function validate(_ref, done) {
      var _this = this;

      var source = _ref.source,
          mediaType = _ref.mediaType,
          adapterOptions = _ref.adapterOptions;

      var adapter = this.findAdapter(source, mediaType, 'validate');

      if (!adapter) {
        return this.parse({ source: source, mediaType: mediaType, adapterOptions: adapterOptions }, function (err, result) {
          if (result && result.annotations.length > 0) {
            var ParseResult = _this.minim.elements.ParseResult;

            var parseResult = new ParseResult(result.annotations);
            done(err, parseResult);
          } else {
            done(err, null);
          }
        });
      }

      var options = { minim: this.minim, source: source };

      if (adapterOptions) {
        options = Object.assign(options, adapterOptions);
      }

      return adapter.validate(options, function (err, elements) {
        if (!elements || elements instanceof _this.minim.Element) {
          done(err, elements);
        } else {
          done(err, _this.load(elements));
        }
      });
    }

    /*
     * Parse an input document into Javascript objects. This method uses
     * the registered adapters to automatically detect the input format,
     * then uses the adapter to convert into refract elements and loads
     * these into objects.
     */

  }, {
    key: 'parse',
    value: function parse(_ref2, done) {
      var _this2 = this;

      var source = _ref2.source,
          mediaType = _ref2.mediaType,
          _ref2$generateSourceM = _ref2.generateSourceMap,
          generateSourceMap = _ref2$generateSourceM === undefined ? false : _ref2$generateSourceM,
          adapterOptions = _ref2.adapterOptions;

      var adapter = this.findAdapter(source, mediaType, 'parse');

      if (!adapter) {
        return done(new Error('Document did not match any registered parsers!'));
      }

      try {
        var options = { generateSourceMap: generateSourceMap, minim: this.minim, source: source };

        if (adapterOptions) {
          options = Object.assign(options, adapterOptions);
        }

        return adapter.parse(options, function (err, elements) {
          if (!elements || elements instanceof _this2.minim.Element) {
            done(err, elements);
          } else {
            done(err, _this2.load(elements));
          }
        });
      } catch (err) {
        return done(err);
      }
    }

    /*
     * Serialize a parsed API into the given output format.
     */

  }, {
    key: 'serialize',
    value: function serialize(_ref3, done) {
      var api = _ref3.api,
          _ref3$mediaType = _ref3.mediaType,
          mediaType = _ref3$mediaType === undefined ? 'text/vnd.apiblueprint' : _ref3$mediaType;

      var adapter = _findAdapter(this.adapters, mediaType, 'serialize');

      if (adapter) {
        try {
          return adapter.serialize({ api: api, minim: this.minim }, done);
        } catch (err) {
          return done(err);
        }
      } else {
        return done(new Error('Media type did not match any registered serializer!'));
      }
    }
  }]);

  return Fury;
}();

/*
  Since we need to provide a sane interface to both ES6 `import` and
  normal Node.js `require` statements, we make a single default export
  and set up some other faux exports within it. See Babel's module
  docs: https://babeljs.io/docs/usage/modules/.
*/


var fury = new Fury();

fury.Fury = Fury;

exports.default = fury;
module.exports = exports['default'];
//# sourceMappingURL=fury.map